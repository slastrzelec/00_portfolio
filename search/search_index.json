{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Witaj w moim portfolio \ud83d\udc4b","text":"<p>Cze\u015b\u0107! Nazywam si\u0119 S\u0142awomir Strzelec i zajmuj\u0119 si\u0119 data science i machine learning. Tutaj znajdziesz moje projekty, do\u015bwiadczenie i osi\u0105gni\u0119cia.</p>"},{"location":"#projekty","title":"Projekty","text":"<ul> <li>Erytrocyty \u2013 analiza kszta\u0142tu erytrocyt\u00f3w i detekcja anomalii  </li> <li>EDA QM9 \u2013 eksploracyjna analiza danych zbioru QM9</li> </ul>"},{"location":"#o-mnie","title":"O mnie","text":"<ul> <li>O mnie \u2013 dowiedz si\u0119 wi\u0119cej o mojej \u015bcie\u017cce i umiej\u0119tno\u015bciach</li> </ul> <p>Portfolio stworzone z u\u017cyciem MkDocs</p> <pre><code>\n## Kluczowe zasady:\n\n\u2705 **Linki w Markdown**: `[Tekst](\u015bcie\u017cka/plik.md)`\n- Bez podkre\u015ble\u0144 `__`\n- Bez `html` - tylko `.md`\n- \u015acie\u017cki wzgl\u0119dne od folderu `docs/`\n\n\u2705 **Struktura katalog\u00f3w musi pasowa\u0107**:\n</code></pre> <p>docs/ \u251c\u2500\u2500 index.md           \u2190 ten plik \u251c\u2500\u2500 o-mnie.md \u251c\u2500\u2500 01_erytro/ \u2502   \u2514\u2500\u2500 index.md \u2514\u2500\u2500 02_eda_chem/       \u2190 uwaga: podkre\u015blnik!     \u2514\u2500\u2500 EDA_QM9.md</p>"},{"location":"o-mnie/","title":"O mnie","text":"<p>Cze\u015b\u0107! \ud83d\udc4b  </p> <p>Nazywam si\u0119 S\u0142awomir Strzelec i jestem pasjonatem data science, machine learning oraz chemii.  </p> <p>Po uko\u0144czeniu studi\u00f3w z chemii i zdobyciu do\u015bwiadczenia w analizie danych chemicznych, postanowi\u0142em po\u0142\u0105czy\u0107 swoj\u0105 wiedz\u0119 naukow\u0105 z umiej\u0119tno\u015bciami w programowaniu i analizie danych. </p> <p>Obecnie skupiam si\u0119 na projektach zwi\u0105zanych z:</p> <ul> <li>Przetwarzaniem i analiz\u0105 danych w Pythonie (Pandas, NumPy, Matplotlib, Seaborn)  </li> <li>Machine learning i modelowaniem predykcyjnym (scikit-learn, PyCaret)  </li> <li>Wizualizacj\u0105 i prezentacj\u0105 danych  </li> </ul>"},{"location":"o-mnie/#moje-umiejetnosci","title":"Moje umiej\u0119tno\u015bci","text":"<ul> <li>Python, SQL, Git, Jupyter Notebook  </li> <li>Analiza danych i statystyka opisowa  </li> <li>Machine learning: regresja, klasyfikacja, feature importance  </li> <li>Chemoinformatyka i analiza zwi\u0105zk\u00f3w chemicznych  </li> </ul>"},{"location":"o-mnie/#moje-projekty","title":"Moje projekty","text":"<p>W moim portfolio znajdziesz projekty, kt\u00f3re pokazuj\u0105 moje umiej\u0119tno\u015bci w praktyce: od analizy wynik\u00f3w wy\u015bcig\u00f3w, przez projekt z erytrocytami, a\u017c po przewidywanie w\u0142a\u015bciwo\u015bci chemicznych z SMILES.  </p>"},{"location":"o-mnie/#kontakt","title":"Kontakt","text":"<ul> <li>\ud83d\udce7 E-mail: twoj.email@example.com </li> <li>\ud83d\udcbc LinkedIn: linkedin.com/in/twoj-profil </li> <li>\ud83d\udc19 GitHub: github.com/slastrzelec </li> </ul> <p>Ch\u0119tnie podejmuj\u0119 nowe wyzwania i rozwijam swoje kompetencje w data science i machine learning. \ud83d\ude80</p>"},{"location":"01_erytro/","title":"\ud83d\udd2c Erythrocyte Analysis App","text":""},{"location":"01_erytro/#project-overview","title":"\ud83e\uddec Project Overview","text":"<p>This project is an interactive Streamlit web application for the automated analysis of erythrocyte (red blood cell) morphology. Using computer vision (OpenCV) and scientific Python libraries, the app extracts key geometric parameters of red blood cells and identifies shape anomalies, which may indicate hematological disorders.</p> <p>The application allows you to:</p> <ul> <li>Upload your own microscope image or use a sample one</li> <li>Automatically detect erythrocytes using contour analysis</li> <li>Calculate Shape Factor, Ellipticity, Area, Perimeter, and axis lengths</li> <li>Identify normal vs. anomalous erythrocytes</li> <li>Apply calibration to convert pixel-size values into micrometers</li> <li>Visualize data using multiple charts</li> <li>Download results as CSV or Excel files</li> <li>Download my associated scientific publication as a PDF</li> </ul>"},{"location":"01_erytro/#key-features","title":"\ud83c\udfaf Key Features","text":""},{"location":"01_erytro/#image-input","title":"\ud83d\udce5 Image Input","text":"<ul> <li>Upload your own <code>.jpg/.jpeg/.png</code> image</li> <li>Or load a default microscope image directly from GitHub</li> <li>Automatic error handling for corrupted files</li> </ul>"},{"location":"01_erytro/#erythrocyte-shape-detection","title":"\ud83e\uddea Erythrocyte Shape Detection","text":"<p>The application performs:</p> <ul> <li>Grayscale conversion</li> <li>Otsu\u2019s thresholding for automatic binarization</li> <li>Contour extraction using OpenCV</li> <li>Ellipse fitting for every detected erythrocyte</li> <li> <p>Calculation of:</p> </li> <li> <p>Shape Factor (major/minor axis)</p> </li> <li>Ellipticity</li> <li>Area</li> <li>Perimeter</li> <li>Major and Minor Axis lengths</li> </ul> <p>Cells are colour-coded:</p> <ul> <li>\ud83d\udfe2 Green \u2014 normal morphology</li> <li>\ud83d\udfe1 Yellow \u2014 moderately elongated</li> <li>\ud83d\udd34 Red \u2014 highly elongated (potential anomaly)</li> <li>\ud83d\udfe3 Magenta \u2014 anomaly detected</li> </ul>"},{"location":"01_erytro/#calibration-mode-m-conversion","title":"\ud83d\udccf Calibration Mode (\u00b5m Conversion)","text":"<p>Users can provide a \u00b5m-per-pixel calibration factor.</p> <p>When enabled, the app automatically adds:</p> <ul> <li>Major Axis (\u00b5m)</li> <li>Minor Axis (\u00b5m)</li> <li>Perimeter (\u00b5m)</li> <li>Area (\u00b5m\u00b2)</li> </ul> <p>If calibration is disabled (value = 0), the measurements remain in pixels.</p>"},{"location":"01_erytro/#data-visualization","title":"\ud83d\udcca Data Visualization","text":"<p>The app generates detailed scientific visualisations:</p> <ul> <li>Scatter plot: Shape Factor vs. Area, with anomaly threshold</li> <li>Histogram: Shape Factor distribution</li> <li>Histogram: Area distribution (px\u00b2 or \u00b5m\u00b2)</li> <li>Histogram: Perimeter distribution</li> <li>Binary mask preview used internally for segmentation</li> <li>Processed image with detected cells and IDs</li> </ul>"},{"location":"01_erytro/#data-export","title":"\ud83d\udccb Data Export","text":"<p>You can download all measurement results as:</p> <ul> <li>CSV (.csv)</li> <li>Excel (.xlsx)</li> </ul> <p>Both export functions use caching for performance.</p>"},{"location":"01_erytro/#scientific-publication","title":"\ud83d\udcd6 Scientific Publication","text":"<p>The app also includes a downloadable PDF of my related research publication:</p> <p>Functionalized carbon nanotubes and their acute effects on erythrocyte oxygen-binding properties.</p> <p>A highlighted abstract is shown inside the app, together with a direct download button.</p>"},{"location":"01_erytro/#tech-stack","title":"\ud83d\udee0\ufe0f Tech Stack","text":"<ul> <li>Python</li> <li>Streamlit \u2014 interactive UI</li> <li>OpenCV (cv2) \u2014 image processing</li> <li>NumPy &amp; Pandas \u2014 scientific computing</li> <li>Matplotlib \u2014 visualizations</li> <li>Requests \u2014 loading remote files</li> <li>OpenPyXL \u2014 Excel export</li> </ul>"},{"location":"01_erytro/#main-functional-flow","title":"\ud83d\ude80 Main Functional Flow","text":"<ol> <li>Load or upload an image</li> <li>Preprocess &amp; apply Otsu threshold</li> <li>Detect contours and fit ellipses</li> <li>Extract metrics for each detected erythrocyte</li> <li>Classify as normal or anomalous</li> <li>Apply calibration (optional)</li> <li>Display processed images</li> <li>Show statistics, charts, and tables</li> <li>Allow CSV / Excel export</li> </ol>"},{"location":"01_erytro/#repository-structure-recommended","title":"\ud83d\udcc1 Repository Structure (recommended)","text":"<pre><code>\ud83d\udce6 erythro-analysis-app\n\u2502\n\u251c\u2500\u2500 app.py                # Main Streamlit application\n\u251c\u2500\u2500 README.md             # Project documentation\n\u251c\u2500\u2500 publikacja.pdf        # Scientific publication\n\u251c\u2500\u2500 requirements.txt      # Dependencies\n\u2514\u2500\u2500 experimental_data/\n        \u2514\u2500\u2500 C.jpg         # Example microscope image\n</code></pre>"},{"location":"01_erytro/#summary","title":"\ud83c\udf89 Summary","text":"<p>This project demonstrates how computer vision, scientific analysis, and interactive UI can be combined to support hematology research. It automates time-consuming manual image interpretation and helps detect early morphological anomalies in erythrocytes \u2014 potentially supporting diagnostic workflows.</p> <p>If you want, I can also:</p> <p>\u2705 Generate a short version for GitHub \u2705 Write a MkDocs page formatted with sections \u2705 Create an English + Polish version side-by-side \u2705 Add animated diagrams or architecture flowcharts</p>"},{"location":"02_eda_chem/EDA_QM9/","title":"EDA Chem","text":"EDA In\u00a0[3]: <pre>import pandas as pd\n\n# \u015acie\u017cka do du\u017cego pliku\ndata = r\"C:\\Users\\slast\\PYTHON\\0_projekty do portfolio\\02_EDA_chem\\qm9_dataset.xlsx\"\n\n# Wczytujemy z opcj\u0105 ograniczenia do wybranych kolumn lub bez \u2013 jak wolisz\ndf = pd.read_excel(data)\n\n# Losowa pr\u00f3bka 1000 wierszy z zachowaniem miksu danych\nsample_df = df.sample(n=1000, random_state=42)\n\n# Zapis nowego pliku roboczego\noutput_path = r\"C:\\Users\\slast\\PYTHON\\0_projekty do portfolio\\02_EDA_chem\\qm9_sample_1000.xlsx\"\nsample_df.to_excel(output_path, index=False)\n\nprint(\"\u2714\ufe0f Utworzono plik roboczy z 1000 wierszy:\")\nprint(output_path)\n</pre> <pre>\u2714\ufe0f Utworzono plik roboczy z 1000 wierszy:\nC:\\Users\\slast\\PYTHON\\0_projekty do portfolio\\02_EDA_chem\\qm9_sample_1000.xlsx\n</pre> In\u00a0[2]: <pre>import pandas as pd\n\ndata = r\"C:\\Users\\slast\\PYTHON\\0_projekty do portfolio\\02_EDA_chem\\qm9_sample_1000.xlsx\"\n\ndf = pd.read_excel(data)\nprint(df.head())\n</pre> <pre>                                                   X        y1        y2  \\\n0  &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF0ED... -1.291747  1.802935   \n1  &lt;rdkit.Chem.rdchem.Mol object at 0x000001BEFC9... -0.644026 -0.218808   \n2  &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF0E0... -0.459969  0.297628   \n3  &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF2AB... -0.775036  1.089651   \n4  &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF0E0...  0.346542 -0.820930   \n\n         y3        y4        y5        y6        y7        y8        y9  ...  \\\n0 -0.427511  0.711080  0.924869  1.096639  1.652419  1.864530  1.112639  ...   \n1  2.287883  0.424803 -0.721806 -0.398991 -0.414869  0.044067 -0.463779  ...   \n2  0.167480  0.130518  0.046509 -0.251763  0.650823  0.217649 -0.113869  ...   \n3 -0.104059  1.107464  1.156964  0.315530  1.703451  1.364106  0.237038  ...   \n4 -0.902704  0.618991  1.072929  0.839014 -0.128690  0.650888 -1.836564  ...   \n\n   w5  w6  w7  w8  w9  w10  w11  w12  \\\n0   1   1   1   1   1    1    1    1   \n1   1   1   1   1   1    1    1    1   \n2   1   1   1   1   1    1    1    1   \n3   1   1   1   1   1    1    1    1   \n4   1   1   1   1   1    1    1    1   \n\n                                                 ids  split  \n0  [H]C([H])([H])C([H])([H])[N@@H+]1C([H])([H])[C...  train  \n1  [H]O[C@@]12C([H])([H])O[C@]1([H])[C@]2([H])[C@...  train  \n2  [H]C1([H])C([H])([H])[C@]2([H])[C@@]1([H])[C@]...  train  \n3    [H]OC([H])([H])[C@]1(C([H])([H])C#N)OC1([H])[H]   test  \n4  [H]N1[C@]2([H])C(=O)[C@@]1([H])C([H])([H])OC2(...  train  \n\n[5 rows x 27 columns]\n</pre> In\u00a0[3]: <pre># ============================================================\n# KOM\u00d3RKA 2: ZMIANA NAZW KOLUMN NA OPISOWE\n# ============================================================\n\n# Mapowanie oryginalnych nazw na opisowe\ncolumn_mapping = {\n    # Identyfikatory i features\n    'ids': 'SMILES',\n    'X': 'SMILES_raw',\n\n    # W\u0142a\u015bciwo\u015bci molekularne (y1-y12)\n    'y1': 'dipole_moment',          # \u03bc (Debye) - moment dipolowy\n    'y2': 'polarizability',         # \u03b1 (Bohr\u00b3) - polaryzowalno\u015b\u0107\n    'y3': 'HOMO',                   # \u03b5HOMO (eV) - energia HOMO\n    'y4': 'LUMO',                   # \u03b5LUMO (eV) - energia LUMO\n    'y5': 'gap',                    # \u0394\u03b5 (eV) - HOMO-LUMO gap\n    'y6': 'electronic_spatial_extent', # \u27e8R\u00b2\u27e9 (Bohr\u00b2) - elektroniczny zasi\u0119g przestrzenny\n    'y7': 'zpve',                   # ZPVE (eV) - zero point vibrational energy\n    'y8': 'U0',                     # U\u2080 (eV) - energia wewn\u0119trzna w 0K\n    'y9': 'U',                      # U (eV) - energia wewn\u0119trzna w 298.15K\n    'y10': 'H',                     # H (eV) - entalpia w 298.15K\n    'y11': 'G',                     # G (eV) - energia swobodna Gibbsa w 298.15K\n    'y12': 'Cv',                    # Cv (cal/mol\u00b7K) - pojemno\u015b\u0107 cieplna w 298.15K\n\n    # Wagi (w1-w12)\n    'w1': 'weight_dipole',\n    'w2': 'weight_polarizability',\n    'w3': 'weight_HOMO',\n    'w4': 'weight_LUMO',\n    'w5': 'weight_gap',\n    'w6': 'weight_R2',\n    'w7': 'weight_zpve',\n    'w8': 'weight_U0',\n    'w9': 'weight_U',\n    'w10': 'weight_H',\n    'w11': 'weight_G',\n    'w12': 'weight_Cv',\n\n    # Split (je\u015bli istnieje)\n    'split': 'dataset_split'\n}\n\n# Zmiana nazw kolumn\ndf = df.rename(columns=column_mapping)\n\n# ============================================================\n# USUNI\u0118CIE KOLUMN Z WAGAMI (wszystkie = 1)\n# ============================================================\n\n# Lista kolumn z wagami do usuni\u0119cia\nweight_columns = [col for col in df.columns if col.startswith('weight_')]\n\nprint(\"=\"*70)\nprint(\"USUWANIE KOLUMN Z WAGAMI\")\nprint(\"=\"*70)\nprint(f\"\\n\ud83d\uddd1\ufe0f  Usuwam {len(weight_columns)} kolumn z wagami:\")\nfor col in weight_columns:\n    print(f\"  \u2022 {col}\")\n\n# Usuni\u0119cie kolumn\ndf = df.drop(columns=weight_columns)\n\nprint(f\"\\n\u2705 Kolumny usuni\u0119te! Pozosta\u0142o {len(df.columns)} kolumn\")\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"ZMIENIONO NAZWY KOLUMN\")\nprint(\"=\"*70)\n\nprint(\"\\n\ud83d\udccb Nowe nazwy kolumn:\")\nfor i, col in enumerate(df.columns, 1):\n    print(f\"  {i:2d}. {col}\")\n\nprint(\"\\n\ud83d\udd0d Pierwsze 3 wiersze po zmianie:\")\nprint(df.head(3))\n\nprint(\"\\n\ud83d\udcca Kszta\u0142t DataFrame:\")\nprint(f\"  Wiersze: {len(df):,}\")\nprint(f\"  Kolumny: {len(df.columns)}\")\n\nprint(\"\\n\u2705 Nazwy kolumn zosta\u0142y zmienione!\")\nprint(\"=\"*70)\n\n# Opcjonalnie: Wy\u015bwietl info o w\u0142a\u015bciwo\u015bciach\nprint(\"\\n\ud83d\udcd6 OPIS W\u0141A\u015aCIWO\u015aCI KWANTOWO-CHEMICZNYCH:\")\nprint(\"-\" * 70)\nproperties_description = {\n    'dipole_moment': 'Moment dipolowy [Debye] - miara polarno\u015bci cz\u0105steczki',\n    'polarizability': 'Polaryzowalno\u015b\u0107 [Bohr\u00b3] - odpowied\u017a na pole elektryczne',\n    'HOMO': 'Energia HOMO [eV] - najwy\u017cszy zaj\u0119ty orbital molekularny',\n    'LUMO': 'Energia LUMO [eV] - najni\u017cszy niezaj\u0119ty orbital molekularny',\n    'gap': 'HOMO-LUMO gap [eV] - r\u00f3\u017cnica energii, kluczowa dla reaktywno\u015bci',\n    'electronic_spatial_extent': 'Elektroniczny zasi\u0119g przestrzenny [Bohr\u00b2]',\n    'zpve': 'Energia drga\u0144 punktu zerowego [eV]',\n    'U0': 'Energia wewn\u0119trzna w 0K [eV]',\n    'U': 'Energia wewn\u0119trzna w 298.15K [eV]',\n    'H': 'Entalpia w 298.15K [eV]',\n    'G': 'Energia swobodna Gibbsa w 298.15K [eV]',\n    'Cv': 'Pojemno\u015b\u0107 cieplna w 298.15K [cal/mol\u00b7K]'\n}\n\nfor prop, desc in properties_description.items():\n    print(f\"  \u2022 {prop:30s} - {desc}\")\n\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nUSUWANIE KOLUMN Z WAGAMI\n======================================================================\n\n\ud83d\uddd1\ufe0f  Usuwam 12 kolumn z wagami:\n  \u2022 weight_dipole\n  \u2022 weight_polarizability\n  \u2022 weight_HOMO\n  \u2022 weight_LUMO\n  \u2022 weight_gap\n  \u2022 weight_R2\n  \u2022 weight_zpve\n  \u2022 weight_U0\n  \u2022 weight_U\n  \u2022 weight_H\n  \u2022 weight_G\n  \u2022 weight_Cv\n\n\u2705 Kolumny usuni\u0119te! Pozosta\u0142o 15 kolumn\n\n======================================================================\nZMIENIONO NAZWY KOLUMN\n======================================================================\n\n\ud83d\udccb Nowe nazwy kolumn:\n   1. SMILES_raw\n   2. dipole_moment\n   3. polarizability\n   4. HOMO\n   5. LUMO\n   6. gap\n   7. electronic_spatial_extent\n   8. zpve\n   9. U0\n  10. U\n  11. H\n  12. G\n  13. Cv\n  14. SMILES\n  15. dataset_split\n\n\ud83d\udd0d Pierwsze 3 wiersze po zmianie:\n                                          SMILES_raw  dipole_moment  \\\n0  &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF0ED...      -1.291747   \n1  &lt;rdkit.Chem.rdchem.Mol object at 0x000001BEFC9...      -0.644026   \n2  &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF0E0...      -0.459969   \n\n   polarizability      HOMO      LUMO       gap  electronic_spatial_extent  \\\n0        1.802935 -0.427511  0.711080  0.924869                   1.096639   \n1       -0.218808  2.287883  0.424803 -0.721806                  -0.398991   \n2        0.297628  0.167480  0.130518  0.046509                  -0.251763   \n\n       zpve        U0         U         H         G        Cv  \\\n0  1.652419  1.864530  1.112639  1.112698  1.112698  1.112566   \n1 -0.414869  0.044067 -0.463779 -0.463790 -0.463790 -0.463751   \n2  0.650823  0.217649 -0.113869 -0.113867 -0.113867 -0.113876   \n\n                                              SMILES dataset_split  \n0  [H]C([H])([H])C([H])([H])[N@@H+]1C([H])([H])[C...         train  \n1  [H]O[C@@]12C([H])([H])O[C@]1([H])[C@]2([H])[C@...         train  \n2  [H]C1([H])C([H])([H])[C@]2([H])[C@@]1([H])[C@]...         train  \n\n\ud83d\udcca Kszta\u0142t DataFrame:\n  Wiersze: 1,000\n  Kolumny: 15\n\n\u2705 Nazwy kolumn zosta\u0142y zmienione!\n======================================================================\n\n\ud83d\udcd6 OPIS W\u0141A\u015aCIWO\u015aCI KWANTOWO-CHEMICZNYCH:\n----------------------------------------------------------------------\n  \u2022 dipole_moment                  - Moment dipolowy [Debye] - miara polarno\u015bci cz\u0105steczki\n  \u2022 polarizability                 - Polaryzowalno\u015b\u0107 [Bohr\u00b3] - odpowied\u017a na pole elektryczne\n  \u2022 HOMO                           - Energia HOMO [eV] - najwy\u017cszy zaj\u0119ty orbital molekularny\n  \u2022 LUMO                           - Energia LUMO [eV] - najni\u017cszy niezaj\u0119ty orbital molekularny\n  \u2022 gap                            - HOMO-LUMO gap [eV] - r\u00f3\u017cnica energii, kluczowa dla reaktywno\u015bci\n  \u2022 electronic_spatial_extent      - Elektroniczny zasi\u0119g przestrzenny [Bohr\u00b2]\n  \u2022 zpve                           - Energia drga\u0144 punktu zerowego [eV]\n  \u2022 U0                             - Energia wewn\u0119trzna w 0K [eV]\n  \u2022 U                              - Energia wewn\u0119trzna w 298.15K [eV]\n  \u2022 H                              - Entalpia w 298.15K [eV]\n  \u2022 G                              - Energia swobodna Gibbsa w 298.15K [eV]\n  \u2022 Cv                             - Pojemno\u015b\u0107 cieplna w 298.15K [cal/mol\u00b7K]\n======================================================================\n</pre> In\u00a0[4]: <pre>df.head(10)\n</pre> Out[4]: SMILES_raw dipole_moment polarizability HOMO LUMO gap electronic_spatial_extent zpve U0 U H G Cv SMILES dataset_split 0 &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF0ED... -1.291747 1.802935 -0.427511 0.711080 0.924869 1.096639 1.652419 1.864530 1.112639 1.112698 1.112698 1.112566 [H]C([H])([H])C([H])([H])[N@@H+]1C([H])([H])[C... train 1 &lt;rdkit.Chem.rdchem.Mol object at 0x000001BEFC9... -0.644026 -0.218808 2.287883 0.424803 -0.721806 -0.398991 -0.414869 0.044067 -0.463779 -0.463790 -0.463790 -0.463751 [H]O[C@@]12C([H])([H])O[C@]1([H])[C@]2([H])[C@... train 2 &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF0E0... -0.459969 0.297628 0.167480 0.130518 0.046509 -0.251763 0.650823 0.217649 -0.113869 -0.113867 -0.113867 -0.113876 [H]C1([H])C([H])([H])[C@]2([H])[C@@]1([H])[C@]... train 3 &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF2AB... -0.775036 1.089651 -0.104059 1.107464 1.156964 0.315530 1.703451 1.364106 0.237038 0.237068 0.237068 0.237016 [H]OC([H])([H])[C@]1(C([H])([H])C#N)OC1([H])[H] test 4 &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF0E0... 0.346542 -0.820930 -0.902704 0.618991 1.072929 0.839014 -0.128690 0.650888 -1.836564 -1.836554 -1.836554 -1.836579 [H]N1[C@]2([H])C(=O)[C@@]1([H])C([H])([H])OC2(... train 5 &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF2A8... 0.409150 -2.145600 -0.758948 -0.494088 -0.113557 -1.271677 -1.391723 -1.357742 -0.503130 -0.503165 -0.503165 -0.503080 [H][N-]C1OC([H])([H])[C@]12[N@@H+]1C([H])([H])... valid 6 &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF2AB... -0.469601 0.294155 0.754484 0.791158 0.412659 -0.396482 0.637064 0.321416 -0.112035 -0.112037 -0.112037 -0.112018 [H]N([H])C1[NH2+][C@]2([H])C([H])([H])[C@]2(C(... test 7 &lt;rdkit.Chem.rdchem.Mol object at 0x000001BEFC5... 0.327348 -0.128489 -0.611199 -1.142716 -0.835853 -0.335116 -1.578459 -1.002448 -0.027435 -0.027466 -0.027466 -0.027395 [H]C1([H])[N@@H+]2[C@@]3([H])[C@]2([H])[C@@]2(... train 8 &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF2A2... 1.261589 -2.541611 -1.797187 -0.974553 -0.073540 -1.369651 -1.949059 -2.116866 0.891255 0.891221 0.891221 0.891306 [H]C([H])([H])O[C@@]1(C([H])([H])[H])C([H])([H... train 9 &lt;rdkit.Chem.rdchem.Mol object at 0x000001BF0E1... 1.653432 -0.118068 0.462979 -1.759313 -1.990326 -0.729647 -1.155817 -1.150208 -0.435730 -0.435769 -0.435769 -0.435686 [H]C(=O)c1c([H])c(N([H])[H])nn1[H] train In\u00a0[5]: <pre># ============================================================\n# KOM\u00d3RKA 3: USUNI\u0118CIE ZB\u0118DNEJ KOLUMNY SMILES_raw\n# ============================================================\n\nprint(\"=\"*70)\nprint(\"USUWANIE ZB\u0118DNEJ KOLUMNY\")\nprint(\"=\"*70)\n\n# Sprawdzenie czy kolumna istnieje\nif 'SMILES_raw' in df.columns:\n    print(\"\\n\ud83d\uddd1\ufe0f  Usuwam kolumn\u0119: SMILES_raw (duplikat SMILES)\")\n    df = df.drop(columns=['SMILES_raw'])\n    print(\"\u2705 Kolumna usuni\u0119ta!\")\nelse:\n    print(\"\\n\u26a0\ufe0f  Kolumna SMILES_raw nie istnieje\")\n\nprint(f\"\\n\ud83d\udcca Aktualne kolumny ({len(df.columns)}):\")\nfor i, col in enumerate(df.columns, 1):\n    print(f\"  {i:2d}. {col}\")\n\nprint(f\"\\n\ud83d\udcc8 Kszta\u0142t DataFrame: {df.shape}\")\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nUSUWANIE ZB\u0118DNEJ KOLUMNY\n======================================================================\n\n\ud83d\uddd1\ufe0f  Usuwam kolumn\u0119: SMILES_raw (duplikat SMILES)\n\u2705 Kolumna usuni\u0119ta!\n\n\ud83d\udcca Aktualne kolumny (14):\n   1. dipole_moment\n   2. polarizability\n   3. HOMO\n   4. LUMO\n   5. gap\n   6. electronic_spatial_extent\n   7. zpve\n   8. U0\n   9. U\n  10. H\n  11. G\n  12. Cv\n  13. SMILES\n  14. dataset_split\n\n\ud83d\udcc8 Kszta\u0142t DataFrame: (1000, 14)\n======================================================================\n</pre> In\u00a0[6]: <pre>df.head(10)\n</pre> Out[6]: dipole_moment polarizability HOMO LUMO gap electronic_spatial_extent zpve U0 U H G Cv SMILES dataset_split 0 -1.291747 1.802935 -0.427511 0.711080 0.924869 1.096639 1.652419 1.864530 1.112639 1.112698 1.112698 1.112566 [H]C([H])([H])C([H])([H])[N@@H+]1C([H])([H])[C... train 1 -0.644026 -0.218808 2.287883 0.424803 -0.721806 -0.398991 -0.414869 0.044067 -0.463779 -0.463790 -0.463790 -0.463751 [H]O[C@@]12C([H])([H])O[C@]1([H])[C@]2([H])[C@... train 2 -0.459969 0.297628 0.167480 0.130518 0.046509 -0.251763 0.650823 0.217649 -0.113869 -0.113867 -0.113867 -0.113876 [H]C1([H])C([H])([H])[C@]2([H])[C@@]1([H])[C@]... train 3 -0.775036 1.089651 -0.104059 1.107464 1.156964 0.315530 1.703451 1.364106 0.237038 0.237068 0.237068 0.237016 [H]OC([H])([H])[C@]1(C([H])([H])C#N)OC1([H])[H] test 4 0.346542 -0.820930 -0.902704 0.618991 1.072929 0.839014 -0.128690 0.650888 -1.836564 -1.836554 -1.836554 -1.836579 [H]N1[C@]2([H])C(=O)[C@@]1([H])C([H])([H])OC2(... train 5 0.409150 -2.145600 -0.758948 -0.494088 -0.113557 -1.271677 -1.391723 -1.357742 -0.503130 -0.503165 -0.503165 -0.503080 [H][N-]C1OC([H])([H])[C@]12[N@@H+]1C([H])([H])... valid 6 -0.469601 0.294155 0.754484 0.791158 0.412659 -0.396482 0.637064 0.321416 -0.112035 -0.112037 -0.112037 -0.112018 [H]N([H])C1[NH2+][C@]2([H])C([H])([H])[C@]2(C(... test 7 0.327348 -0.128489 -0.611199 -1.142716 -0.835853 -0.335116 -1.578459 -1.002448 -0.027435 -0.027466 -0.027466 -0.027395 [H]C1([H])[N@@H+]2[C@@]3([H])[C@]2([H])[C@@]2(... train 8 1.261589 -2.541611 -1.797187 -0.974553 -0.073540 -1.369651 -1.949059 -2.116866 0.891255 0.891221 0.891221 0.891306 [H]C([H])([H])O[C@@]1(C([H])([H])[H])C([H])([H... train 9 1.653432 -0.118068 0.462979 -1.759313 -1.990326 -0.729647 -1.155817 -1.150208 -0.435730 -0.435769 -0.435769 -0.435686 [H]C(=O)c1c([H])c(N([H])[H])nn1[H] train In\u00a0[7]: <pre># ============================================================\n# KOM\u00d3RKA 4: WIZUALIZACJA STRUKTUR MOLEKULARNYCH\n# ============================================================\n\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\nimport matplotlib.pyplot as plt\nfrom matplotlib.gridspec import GridSpec\n\nprint(\"=\"*70)\nprint(\"WIZUALIZACJA PRZYK\u0141ADOWYCH CZ\u0104STECZEK\")\nprint(\"=\"*70)\n\n# ============================================================\n# Wyb\u00f3r przyk\u0142adowych cz\u0105steczek\n# ============================================================\n\n# Losowe pr\u00f3bki z datasetu\nn_samples = 12\nsample_molecules = df.sample(n=n_samples, random_state=42)\n\nprint(f\"\\n\ud83d\udd2c Wybieram {n_samples} losowych cz\u0105steczek do wizualizacji...\\n\")\n\n# ============================================================\n# Przygotowanie moleku\u0142 RDKit\n# ============================================================\n\nmolecules = []\nlabels = []\n\nfor idx, row in sample_molecules.iterrows():\n    smiles = row['SMILES']\n    mol = Chem.MolFromSmiles(smiles)\n\n    if mol is not None:\n        # Informacje o cz\u0105steczce\n        gap = row['gap'] if 'gap' in row else None\n        homo = row['HOMO'] if 'HOMO' in row else None\n\n        # Label z kluczowymi informacjami\n        label = f\"ID: {idx}\\n\"\n        label += f\"SMILES: {smiles[:20]}{'...' if len(smiles) &gt; 20 else ''}\\n\"\n        if gap is not None:\n            label += f\"Gap: {gap:.3f} eV\"\n\n        molecules.append(mol)\n        labels.append(label)\n\n        print(f\"  \u2713 Cz\u0105steczka {len(molecules):2d}: {smiles[:40]}{'...' if len(smiles) &gt; 40 else ''}\")\n\nprint(f\"\\n\u2705 Przygotowano {len(molecules)} struktur do wizualizacji\")\n\n# ============================================================\n# Wizualizacja - Grid 3x4\n# ============================================================\n\nprint(\"\\n\ud83c\udfa8 Generowanie wizualizacji...\\n\")\n\nfig = plt.figure(figsize=(16, 12))\ngs = GridSpec(3, 4, figure=fig, hspace=0.4, wspace=0.3)\n\nfor i, (mol, label) in enumerate(zip(molecules, labels)):\n    row = i // 4\n    col = i % 4\n\n    ax = fig.add_subplot(gs[row, col])\n\n    # Rysowanie cz\u0105steczki\n    img = Draw.MolToImage(mol, size=(400, 400))\n    ax.imshow(img)\n    ax.axis('off')\n    ax.set_title(label, fontsize=9, pad=10)\n\nplt.suptitle('Przyk\u0142adowe cz\u0105steczki z datasetu QM9', \n             fontsize=16, fontweight='bold', y=0.98)\n\nplt.tight_layout()\nplt.savefig('qm9_example_molecules.png', dpi=300, bbox_inches='tight')\nprint(\"\u2705 Zapisano: qm9_example_molecules.png\")\nplt.show()\n\n# ============================================================\n# Wizualizacja cz\u0105steczek o ekstremalnych w\u0142a\u015bciwo\u015bciach\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"CZ\u0104STECZKI O EKSTREMALNYCH W\u0141A\u015aCIWO\u015aCIACH\")\nprint(\"=\"*70)\n\n# Najwy\u017cszy i najni\u017cszy gap\nidx_max_gap = df['gap'].idxmax()\nidx_min_gap = df['gap'].idxmin()\n\n# Najwy\u017cszy i najni\u017cszy moment dipolowy\nidx_max_dipole = df['dipole_moment'].idxmax()\nidx_min_dipole = df['dipole_moment'].idxmin()\n\nextreme_indices = [idx_max_gap, idx_min_gap, idx_max_dipole, idx_min_dipole]\nextreme_labels_text = [\n    f\"Najwy\u017cszy gap: {df.loc[idx_max_gap, 'gap']:.3f} eV\",\n    f\"Najni\u017cszy gap: {df.loc[idx_min_gap, 'gap']:.3f} eV\",\n    f\"Najwy\u017cszy dipole: {df.loc[idx_max_dipole, 'dipole_moment']:.3f} D\",\n    f\"Najni\u017cszy dipole: {df.loc[idx_min_dipole, 'dipole_moment']:.3f} D\"\n]\n\nprint(\"\\n\ud83d\udd0d Ekstremalne cz\u0105steczki:\")\nfor i, (idx, text) in enumerate(zip(extreme_indices, extreme_labels_text), 1):\n    smiles = df.loc[idx, 'SMILES']\n    print(f\"  {i}. {text}\")\n    print(f\"     SMILES: {smiles}\")\n\n# Wizualizacja ekstremalnych cz\u0105steczek\nfig, axes = plt.subplots(2, 2, figsize=(12, 12))\naxes = axes.flatten()\n\nfor i, (idx, label_text) in enumerate(zip(extreme_indices, extreme_labels_text)):\n    smiles = df.loc[idx, 'SMILES']\n    mol = Chem.MolFromSmiles(smiles)\n\n    if mol is not None:\n        img = Draw.MolToImage(mol, size=(500, 500))\n        axes[i].imshow(img)\n        axes[i].axis('off')\n        axes[i].set_title(f\"{label_text}\\nSMILES: {smiles[:30]}{'...' if len(smiles) &gt; 30 else ''}\", \n                         fontsize=10, fontweight='bold', pad=10)\n\nplt.suptitle('Cz\u0105steczki o ekstremalnych w\u0142a\u015bciwo\u015bciach', \n             fontsize=14, fontweight='bold', y=0.98)\nplt.tight_layout()\nplt.savefig('qm9_extreme_molecules.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_extreme_molecules.png\")\nplt.show()\n\n# ============================================================\n# Przyk\u0142ady wed\u0142ug rozmiaru\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"CZ\u0104STECZKI WED\u0141UG ROZMIARU\")\nprint(\"=\"*70)\n\n# Dodanie kolumny z liczb\u0105 atom\u00f3w\ndf['num_atoms'] = df['SMILES'].apply(lambda x: Chem.MolFromSmiles(x).GetNumAtoms() \n                                      if Chem.MolFromSmiles(x) is not None else 0)\n\n# Najmniejsze i najwi\u0119ksze\nidx_smallest = df['num_atoms'].idxmin()\nidx_largest = df['num_atoms'].idxmax()\n\n# \u015arednie\nmedian_atoms = df['num_atoms'].median()\nidx_medium = df.iloc[(df['num_atoms'] - median_atoms).abs().argsort()[:1]].index[0]\n\nsize_indices = [idx_smallest, idx_medium, idx_largest]\nsize_labels = [\n    f\"Najmniejsza ({df.loc[idx_smallest, 'num_atoms']} atom\u00f3w)\",\n    f\"\u015arednia ({df.loc[idx_medium, 'num_atoms']} atom\u00f3w)\",\n    f\"Najwi\u0119ksza ({df.loc[idx_largest, 'num_atoms']} atom\u00f3w)\"\n]\n\nprint(\"\\n\ud83d\udccf Cz\u0105steczki wed\u0142ug rozmiaru:\")\nfor label, idx in zip(size_labels, size_indices):\n    smiles = df.loc[idx, 'SMILES']\n    print(f\"  \u2022 {label}: {smiles}\")\n\n# Wizualizacja\nfig, axes = plt.subplots(1, 3, figsize=(15, 5))\n\nfor i, (idx, label) in enumerate(zip(size_indices, size_labels)):\n    smiles = df.loc[idx, 'SMILES']\n    mol = Chem.MolFromSmiles(smiles)\n\n    if mol is not None:\n        img = Draw.MolToImage(mol, size=(500, 500))\n        axes[i].imshow(img)\n        axes[i].axis('off')\n        axes[i].set_title(f\"{label}\\n{smiles}\", fontsize=10, fontweight='bold')\n\nplt.suptitle('Por\u00f3wnanie rozmiaru cz\u0105steczek', fontsize=14, fontweight='bold')\nplt.tight_layout()\nplt.savefig('qm9_size_comparison.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_size_comparison.png\")\nplt.show()\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\u2705 WIZUALIZACJE ZAKO\u0143CZONE!\")\nprint(\"   Wygenerowano 3 pliki PNG z strukturami molekularnymi\")\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nWIZUALIZACJA PRZYK\u0141ADOWYCH CZ\u0104STECZEK\n======================================================================\n\n\ud83d\udd2c Wybieram 12 losowych cz\u0105steczek do wizualizacji...\n\n  \u2713 Cz\u0105steczka  1: [H]Oc1c([H])c(N([H])[H])n([H])c1C([H])([...\n  \u2713 Cz\u0105steczka  2: [H]O[C@]1([H])C([H])([H])[N@@H+]2C([H])(...\n  \u2713 Cz\u0105steczka  3: [H]C(=O)[C@]1(C([H])([H])[H])C([H])([H])...\n  \u2713 Cz\u0105steczka  4: [H]OC([H])([H])[C@](O[H])(C([H])([H])[H]...\n  \u2713 Cz\u0105steczka  5: [H]OC([H])([H])[C@]12[C@@]3([H])[C@]4([H...\n  \u2713 Cz\u0105steczka  6: [H][N-]C1O[C@@]2([H])[C@@]([H])(O1)[C@@]...\n  \u2713 Cz\u0105steczka  7: [H]C([H])([H])OC(=O)[C@@]([H])(OC([H])([...\n  \u2713 Cz\u0105steczka  8: [H]C1([H])O[C@@]12[C@@]1([H])[N@H+]3[C@]...\n  \u2713 Cz\u0105steczka  9: [H]OC([H])([H])C([H])([H])N(C([H])=O)C([...\n  \u2713 Cz\u0105steczka 10: [H]C1=C([H])[C@@]([H])(C([H])([H])[H])OC...\n  \u2713 Cz\u0105steczka 11: [H]C#C[C@@]1([C@]([H])(O[H])C([H])([H])O...\n  \u2713 Cz\u0105steczka 12: [H]Oc1nc(N([H])C([H])([H])[H])oc1C([H])(...\n\n\u2705 Przygotowano 12 struktur do wizualizacji\n\n\ud83c\udfa8 Generowanie wizualizacji...\n\n</pre> <pre>C:\\Users\\slast\\AppData\\Local\\Temp\\ipykernel_6436\\3317227650.py:77: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.\n  plt.tight_layout()\n</pre> <pre>\u2705 Zapisano: qm9_example_molecules.png\n</pre> <pre>\n======================================================================\nCZ\u0104STECZKI O EKSTREMALNYCH W\u0141A\u015aCIWO\u015aCIACH\n======================================================================\n\n\ud83d\udd0d Ekstremalne cz\u0105steczki:\n  1. Najwy\u017cszy gap: 4.752 eV\n     SMILES: [H]C#C[C@@]1(C([H])([H])C([H])=O)N([H])[C@]1([H])C([H])([H])[H]\n  2. Najni\u017cszy gap: -2.537 eV\n     SMILES: [H]C1=C([H])c2c(oc([H])c2[H])C1=O\n  3. Najwy\u017cszy dipole: 4.349 D\n     SMILES: [H]C1=C([H])c2c(oc([H])c2[H])C1=O\n  4. Najni\u017cszy dipole: -1.694 D\n     SMILES: [H]C#C[C@@]1(C([H])([H])C([H])=O)N([H])[C@]1([H])C([H])([H])[H]\n\n\u2705 Zapisano: qm9_extreme_molecules.png\n</pre> <pre>\n======================================================================\nCZ\u0104STECZKI WED\u0141UG ROZMIARU\n======================================================================\n\n\ud83d\udccf Cz\u0105steczki wed\u0142ug rozmiaru:\n  \u2022 Najmniejsza (4 atom\u00f3w): [H]N([H])C(=O)C([H])([H])[H]\n  \u2022 \u015arednia (9 atom\u00f3w): [H]O[C@@]12C([H])([H])O[C@]1([H])[C@]2([H])[C@]([H])(O[H])C([H])([H])[H]\n  \u2022 Najwi\u0119ksza (11 atom\u00f3w): [H]/N=C(/C(=O)N(/C([H])=N/[H])C([H])([H])[H])N([H])[H]\n\n\u2705 Zapisano: qm9_size_comparison.png\n</pre> <pre>\n======================================================================\n\u2705 WIZUALIZACJE ZAKO\u0143CZONE!\n   Wygenerowano 3 pliki PNG z strukturami molekularnymi\n======================================================================\n</pre> In\u00a0[8]: <pre># ============================================================\n# SPRAWDZANIE BRAKUJ\u0104CYCH WARTO\u015aCI\n# ============================================================\nmissing_counts = df.isnull().sum()\ntotal_missing = missing_counts.sum()\n\nif total_missing == 0:\n    print(\"\u2714\ufe0f Brak brakuj\u0105cych warto\u015bci w zbiorze danych.\")\nelse:\n    print(f\"\u26a0\ufe0f Znaleziono {total_missing} brakuj\u0105cych warto\u015bci w zbiorze danych:\")\n    print(missing_counts[missing_counts &gt; 0])\n\n# ============================================================\n# SPRAWDZANIE DUPLIKAT\u00d3W\n# ============================================================\nduplicate_count = df.duplicated().sum()\n\nif duplicate_count == 0:\n    print(\"\u2714\ufe0f Brak duplikat\u00f3w w zbiorze danych.\")\nelse:\n    print(f\"\u26a0\ufe0f Znaleziono {duplicate_count} duplikat\u00f3w w zbiorze danych.\")\n</pre> <pre>\u2714\ufe0f Brak brakuj\u0105cych warto\u015bci w zbiorze danych.\n\u2714\ufe0f Brak duplikat\u00f3w w zbiorze danych.\n</pre> In\u00a0[9]: <pre>import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# ============================================================\n# WYBIERAMY TYLKO KOLUMNY NUMERYCZNE\n# ============================================================\nnumeric_cols = df.select_dtypes(include=['float64', 'int64']).columns\n\nprint(\"\ud83d\udcca Sprawdzenie warto\u015bci odstaj\u0105cych w kolumnach numerycznych:\\n\")\n\nfor col in numeric_cols:\n    Q1 = df[col].quantile(0.25)\n    Q3 = df[col].quantile(0.75)\n    IQR = Q3 - Q1\n    lower_bound = Q1 - 1.5 * IQR\n    upper_bound = Q3 + 1.5 * IQR\n    outliers = df[(df[col] &lt; lower_bound) | (df[col] &gt; upper_bound)]\n\n    print(f\"{col}: {len(outliers)} warto\u015bci odstaj\u0105cych\")\n\n# ============================================================\n# BOX PLOTY DLA KOLUMN NUMERYCZNYCH\n# ============================================================\nplt.figure(figsize=(15, len(numeric_cols)*1.5))\nfor i, col in enumerate(numeric_cols, 1):\n    plt.subplot(len(numeric_cols), 1, i)\n    sns.boxplot(x=df[col], color='skyblue')\n    plt.title(f\"Boxplot: {col}\")\n    plt.tight_layout()\n\nplt.show()\n</pre> <pre>\ud83d\udcca Sprawdzenie warto\u015bci odstaj\u0105cych w kolumnach numerycznych:\n\ndipole_moment: 10 warto\u015bci odstaj\u0105cych\npolarizability: 33 warto\u015bci odstaj\u0105cych\nHOMO: 68 warto\u015bci odstaj\u0105cych\nLUMO: 0 warto\u015bci odstaj\u0105cych\ngap: 2 warto\u015bci odstaj\u0105cych\nelectronic_spatial_extent: 70 warto\u015bci odstaj\u0105cych\nzpve: 3 warto\u015bci odstaj\u0105cych\nU0: 17 warto\u015bci odstaj\u0105cych\nU: 25 warto\u015bci odstaj\u0105cych\nH: 25 warto\u015bci odstaj\u0105cych\nG: 25 warto\u015bci odstaj\u0105cych\nCv: 25 warto\u015bci odstaj\u0105cych\nnum_atoms: 195 warto\u015bci odstaj\u0105cych\n</pre> In\u00a0[10]: <pre>print(df.columns)\n</pre> <pre>Index(['dipole_moment', 'polarizability', 'HOMO', 'LUMO', 'gap',\n       'electronic_spatial_extent', 'zpve', 'U0', 'U', 'H', 'G', 'Cv',\n       'SMILES', 'dataset_split', 'num_atoms'],\n      dtype='object')\n</pre> In\u00a0[11]: <pre># ============================================================\n# WY\u015aWIETLANIE CZ\u0104STECZEK Z WARTO\u015aCIAMI ODSTAJ\u0104CYMI\n# ============================================================\n\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\n\n# Nazwa kolumny SMILES w Twoim df\nsmiles_col = 'SMILES'\n\n# Sprawdzenie, kt\u00f3re kolumny numeryczne maj\u0105 warto\u015bci odstaj\u0105ce\nnumeric_cols = df.select_dtypes(include=['float64', 'int64']).columns\n\n# Zbieramy wszystkie indeksy z warto\u015bciami odstaj\u0105cymi\noutlier_indices = set()\n\nfor col in numeric_cols:\n    Q1 = df[col].quantile(0.25)\n    Q3 = df[col].quantile(0.75)\n    IQR = Q3 - Q1\n    lower_bound = Q1 - 1.5 * IQR\n    upper_bound = Q3 + 1.5 * IQR\n    outliers = df[(df[col] &lt; lower_bound) | (df[col] &gt; upper_bound)]\n    outlier_indices.update(outliers.index.tolist())\n\n# Wybieramy np. pierwsze 5 cz\u0105steczek z warto\u015bciami odstaj\u0105cymi\nsample_outliers = df.loc[list(outlier_indices)[:5], smiles_col]\n\n# Konwersja SMILES na obiekty RDKit\nmols = [Chem.MolFromSmiles(s) for s in sample_outliers]\n\n# Wy\u015bwietlenie cz\u0105steczek\nDraw.MolsToGridImage(\n    mols, \n    molsPerRow=5, \n    subImgSize=(200,200), \n    legends=[f\"{i+1}\" for i in range(len(mols))]\n)\n</pre> Out[11]: In\u00a0[12]: <pre># ============================================================\n# KOM\u00d3RKA 5: ANALIZA KORELACJI MI\u0118DZY W\u0141A\u015aCIWO\u015aCIAMI\n# ============================================================\n\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nprint(\"=\"*70)\nprint(\"ANALIZA KORELACJI - W\u0141A\u015aCIWO\u015aCI QM9\")\nprint(\"=\"*70)\n\n# ============================================================\n# Przygotowanie danych numerycznych\n# ============================================================\n\n# Wyb\u00f3r tylko kolumn numerycznych (bez SMILES i split)\nnumeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()\n\n# Usuni\u0119cie kolumny num_atoms je\u015bli istnieje (dodana w poprzedniej kom\u00f3rce)\nif 'num_atoms' in numeric_cols:\n    numeric_cols.remove('num_atoms')\n\nprint(f\"\\n\ud83d\udcca Analizowane w\u0142a\u015bciwo\u015bci ({len(numeric_cols)}):\")\nfor i, col in enumerate(numeric_cols, 1):\n    print(f\"  {i:2d}. {col}\")\n\ndf_numeric = df[numeric_cols].copy()\n\n# ============================================================\n# 1. MACIERZ KORELACJI - PE\u0141NA\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"1. PE\u0141NA MACIERZ KORELACJI PEARSONA\")\nprint(\"=\"*70)\n\n# Obliczenie korelacji\ncorrelation_matrix = df_numeric.corr(method='pearson')\n\nprint(f\"\\n\u2713 Macierz korelacji obliczona: {correlation_matrix.shape}\")\n\n# Wizualizacja - pe\u0142na macierz\nplt.figure(figsize=(14, 12))\nmask = np.triu(np.ones_like(correlation_matrix, dtype=bool), k=1)\n\nsns.heatmap(correlation_matrix, \n            mask=mask,\n            annot=True, \n            fmt='.2f', \n            cmap='RdBu_r', \n            center=0,\n            square=True,\n            linewidths=0.5,\n            cbar_kws={\"shrink\": 0.8, \"label\": \"Korelacja Pearsona\"},\n            vmin=-1, \n            vmax=1)\n\nplt.title('Macierz korelacji w\u0142a\u015bciwo\u015bci kwantowo-chemicznych\\n(Korelacja Pearsona)', \n          fontsize=14, fontweight='bold', pad=20)\nplt.xticks(rotation=45, ha='right')\nplt.yticks(rotation=0)\nplt.tight_layout()\nplt.savefig('qm9_correlation_full.png', dpi=300, bbox_inches='tight')\nprint(\"\u2705 Zapisano: qm9_correlation_full.png\")\nplt.show()\n\n# ============================================================\n# 2. NAJSILNIEJSZE KORELACJE\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"2. TOP 15 NAJSILNIEJSZYCH KORELACJI\")\nprint(\"=\"*70)\n\n# Ekstrakcja par korelacji (bez diagonali i duplikat\u00f3w)\ncorrelations_list = []\nfor i in range(len(correlation_matrix.columns)):\n    for j in range(i+1, len(correlation_matrix.columns)):\n        correlations_list.append({\n            'Feature 1': correlation_matrix.columns[i],\n            'Feature 2': correlation_matrix.columns[j],\n            'Correlation': correlation_matrix.iloc[i, j]\n        })\n\ndf_correlations = pd.DataFrame(correlations_list)\ndf_correlations['Abs_Correlation'] = df_correlations['Correlation'].abs()\ndf_correlations = df_correlations.sort_values('Abs_Correlation', ascending=False)\n\nprint(\"\\n\ud83d\udd1d TOP 15 najsilniejszych korelacji (warto\u015b\u0107 bezwzgl\u0119dna):\")\nprint(\"-\" * 70)\nfor idx, row in df_correlations.head(15).iterrows():\n    print(f\"  {row['Feature 1']:25s} \u2194 {row['Feature 2']:25s}  r = {row['Correlation']:+.4f}\")\n\n# Wizualizacja top korelacji\ntop_n = 15\ntop_correlations = df_correlations.head(top_n).copy()\ntop_correlations['Pair'] = (top_correlations['Feature 1'] + '\\n\u2194\\n' + \n                             top_correlations['Feature 2'])\n\nplt.figure(figsize=(12, 8))\ncolors = ['#d73027' if x &lt; 0 else '#4575b4' for x in top_correlations['Correlation']]\nbars = plt.barh(range(len(top_correlations)), \n                top_correlations['Correlation'], \n                color=colors, \n                edgecolor='black', \n                linewidth=0.7)\n\nplt.yticks(range(len(top_correlations)), top_correlations['Pair'], fontsize=9)\nplt.xlabel('Wsp\u00f3\u0142czynnik korelacji Pearsona', fontsize=12, fontweight='bold')\nplt.title('Top 15 najsilniejszych korelacji mi\u0119dzy w\u0142a\u015bciwo\u015bciami', \n          fontsize=14, fontweight='bold', pad=20)\nplt.axvline(x=0, color='black', linewidth=0.8, linestyle='-')\nplt.grid(axis='x', alpha=0.3, linestyle='--')\n\n# Dodanie warto\u015bci na s\u0142upkach\nfor i, (bar, val) in enumerate(zip(bars, top_correlations['Correlation'])):\n    plt.text(val + 0.02 if val &gt; 0 else val - 0.02, \n             i, \n             f'{val:.3f}', \n             va='center', \n             ha='left' if val &gt; 0 else 'right',\n             fontweight='bold',\n             fontsize=9)\n\nplt.tight_layout()\nplt.savefig('qm9_top_correlations.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_top_correlations.png\")\nplt.show()\n\n# ============================================================\n# 3. KORELACJA HOMO-LUMO-GAP (kluczowe w\u0142a\u015bciwo\u015bci)\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"3. ANALIZA HOMO-LUMO-GAP\")\nprint(\"=\"*70)\n\n# Korelacje z gap\ngap_correlations = correlation_matrix['gap'].sort_values(ascending=False)\nprint(\"\\n\ud83d\udcca Korelacje z HOMO-LUMO gap:\")\nprint(\"-\" * 70)\nfor prop, corr in gap_correlations.items():\n    if prop != 'gap':\n        print(f\"  {prop:30s}  r = {corr:+.4f}\")\n\n# Scatter plots - HOMO, LUMO, gap\nfig, axes = plt.subplots(1, 3, figsize=(18, 5))\n\n# Sample dla szybszej wizualizacji\ndf_sample = df_numeric.sample(n=min(5000, len(df_numeric)), random_state=42)\n\n# HOMO vs LUMO\naxes[0].scatter(df_sample['HOMO'], df_sample['LUMO'], \n                alpha=0.3, s=10, c='#1f77b4', edgecolors='none')\naxes[0].set_xlabel('HOMO (eV)', fontsize=11, fontweight='bold')\naxes[0].set_ylabel('LUMO (eV)', fontsize=11, fontweight='bold')\naxes[0].set_title(f'HOMO vs LUMO\\nr = {correlation_matrix.loc[\"HOMO\", \"LUMO\"]:.3f}', \n                  fontsize=12, fontweight='bold')\naxes[0].grid(alpha=0.3)\n\n# HOMO vs gap\naxes[1].scatter(df_sample['HOMO'], df_sample['gap'], \n                alpha=0.3, s=10, c='#ff7f0e', edgecolors='none')\naxes[1].set_xlabel('HOMO (eV)', fontsize=11, fontweight='bold')\naxes[1].set_ylabel('gap (eV)', fontsize=11, fontweight='bold')\naxes[1].set_title(f'HOMO vs gap\\nr = {correlation_matrix.loc[\"HOMO\", \"gap\"]:.3f}', \n                  fontsize=12, fontweight='bold')\naxes[1].grid(alpha=0.3)\n\n# LUMO vs gap\naxes[2].scatter(df_sample['LUMO'], df_sample['gap'], \n                alpha=0.3, s=10, c='#2ca02c', edgecolors='none')\naxes[2].set_xlabel('LUMO (eV)', fontsize=11, fontweight='bold')\naxes[2].set_ylabel('gap (eV)', fontsize=11, fontweight='bold')\naxes[2].set_title(f'LUMO vs gap\\nr = {correlation_matrix.loc[\"LUMO\", \"gap\"]:.3f}', \n                  fontsize=12, fontweight='bold')\naxes[2].grid(alpha=0.3)\n\nplt.suptitle('Zale\u017cno\u015bci mi\u0119dzy kluczowymi w\u0142a\u015bciwo\u015bciami elektronowymi', \n             fontsize=14, fontweight='bold', y=1.02)\nplt.tight_layout()\nplt.savefig('qm9_homo_lumo_gap.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_homo_lumo_gap.png\")\nplt.show()\n\n# ============================================================\n# 4. PAIRPLOT - WYBRANE W\u0141A\u015aCIWO\u015aCI\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"4. PAIRPLOT - KLUCZOWE W\u0141A\u015aCIWO\u015aCI\")\nprint(\"=\"*70)\n\n# Wyb\u00f3r najwa\u017cniejszych w\u0142a\u015bciwo\u015bci\nkey_properties = ['HOMO', 'LUMO', 'gap', 'dipole_moment', 'polarizability']\n\nprint(f\"\\n\ud83d\udcc8 Tworzenie pairplot dla {len(key_properties)} w\u0142a\u015bciwo\u015bci...\")\nprint(f\"   U\u017cywam {min(2000, len(df))} pr\u00f3bek dla szybszej wizualizacji\")\n\ndf_pairplot = df[key_properties].sample(n=min(2000, len(df)), random_state=42)\n\n# Pairplot\npairplot_fig = sns.pairplot(df_pairplot, \n                             diag_kind='kde',\n                             plot_kws={'alpha': 0.4, 's': 15, 'edgecolor': 'none'},\n                             diag_kws={'linewidth': 2})\n\npairplot_fig.fig.suptitle('Pairplot kluczowych w\u0142a\u015bciwo\u015bci kwantowo-chemicznych', \n                          fontsize=14, fontweight='bold', y=1.01)\n\nplt.savefig('qm9_pairplot.png', dpi=300, bbox_inches='tight')\nprint(\"\u2705 Zapisano: qm9_pairplot.png\")\nplt.show()\n\n# ============================================================\n# 5. KORELACJA SPEARMANA (dla sprawdzenia nieliniowych zale\u017cno\u015bci)\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"5. POR\u00d3WNANIE KORELACJI PEARSONA vs SPEARMANA\")\nprint(\"=\"*70)\n\n# Korelacja Spearmana\nspearman_matrix = df_numeric.corr(method='spearman')\n\n# R\u00f3\u017cnica mi\u0119dzy Pearson a Spearman\ndiff_matrix = np.abs(correlation_matrix - spearman_matrix)\n\nprint(\"\\n\ud83d\udcca Najwi\u0119ksze r\u00f3\u017cnice mi\u0119dzy Pearson a Spearman (nieliniowo\u015bci):\")\nprint(\"-\" * 70)\n\n# Znalezienie najwi\u0119kszych r\u00f3\u017cnic\nmax_diffs = []\nfor i in range(len(diff_matrix.columns)):\n    for j in range(i+1, len(diff_matrix.columns)):\n        max_diffs.append({\n            'Feature 1': diff_matrix.columns[i],\n            'Feature 2': diff_matrix.columns[j],\n            'Pearson': correlation_matrix.iloc[i, j],\n            'Spearman': spearman_matrix.iloc[i, j],\n            'Difference': diff_matrix.iloc[i, j]\n        })\n\ndf_diffs = pd.DataFrame(max_diffs).sort_values('Difference', ascending=False)\n\nfor idx, row in df_diffs.head(10).iterrows():\n    print(f\"  {row['Feature 1']:20s} \u2194 {row['Feature 2']:20s}\")\n    print(f\"    Pearson: {row['Pearson']:+.4f}  |  Spearman: {row['Spearman']:+.4f}  |  Diff: {row['Difference']:.4f}\")\n\n# ============================================================\n# 6. PODSUMOWANIE STATYSTYCZNE\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"6. PODSUMOWANIE ANALIZY KORELACJI\")\nprint(\"=\"*70)\n\nprint(f\"\"\"\n\ud83d\udcca STATYSTYKI KORELACJI:\n\n\u2022 Liczba analizowanych w\u0142a\u015bciwo\u015bci: {len(numeric_cols)}\n\u2022 Liczba par korelacji: {len(correlations_list)}\n\n\u2022 Najsilniejsza korelacja dodatnia:\n  {df_correlations.iloc[0]['Feature 1']} \u2194 {df_correlations.iloc[0]['Feature 2']}\n  r = {df_correlations.iloc[0]['Correlation']:.4f}\n\n\u2022 Najsilniejsza korelacja ujemna:\n  {df_correlations[df_correlations['Correlation'] &lt; 0].iloc[0]['Feature 1']} \u2194 {df_correlations[df_correlations['Correlation'] &lt; 0].iloc[0]['Feature 2']}\n  r = {df_correlations[df_correlations['Correlation'] &lt; 0].iloc[0]['Correlation']:.4f}\n\n\u2022 Silne korelacje (|r| &gt; 0.7): {len(df_correlations[df_correlations['Abs_Correlation'] &gt; 0.7])}\n\u2022 \u015arednie korelacje (0.3 &lt; |r| &lt; 0.7): {len(df_correlations[(df_correlations['Abs_Correlation'] &gt; 0.3) &amp; (df_correlations['Abs_Correlation'] &lt;= 0.7)])}\n\u2022 S\u0142abe korelacje (|r| &lt; 0.3): {len(df_correlations[df_correlations['Abs_Correlation'] &lt;= 0.3])}\n\"\"\")\n\nprint(\"=\"*70)\nprint(\"\u2705 ANALIZA KORELACJI ZAKO\u0143CZONA!\")\nprint(\"   Wygenerowano 4 pliki PNG z wizualizacjami\")\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nANALIZA KORELACJI - W\u0141A\u015aCIWO\u015aCI QM9\n======================================================================\n\n\ud83d\udcca Analizowane w\u0142a\u015bciwo\u015bci (12):\n   1. dipole_moment\n   2. polarizability\n   3. HOMO\n   4. LUMO\n   5. gap\n   6. electronic_spatial_extent\n   7. zpve\n   8. U0\n   9. U\n  10. H\n  11. G\n  12. Cv\n\n======================================================================\n1. PE\u0141NA MACIERZ KORELACJI PEARSONA\n======================================================================\n\n\u2713 Macierz korelacji obliczona: (12, 12)\n\u2705 Zapisano: qm9_correlation_full.png\n</pre> <pre>\n======================================================================\n2. TOP 15 NAJSILNIEJSZYCH KORELACJI\n======================================================================\n\n\ud83d\udd1d TOP 15 najsilniejszych korelacji (warto\u015b\u0107 bezwzgl\u0119dna):\n----------------------------------------------------------------------\n  H                         \u2194 G                          r = +1.0000\n  U                         \u2194 H                          r = +1.0000\n  U                         \u2194 G                          r = +1.0000\n  U                         \u2194 Cv                         r = +1.0000\n  H                         \u2194 Cv                         r = +1.0000\n  G                         \u2194 Cv                         r = +1.0000\n  LUMO                      \u2194 gap                        r = +0.8670\n  electronic_spatial_extent \u2194 U0                         r = +0.8288\n  polarizability            \u2194 U0                         r = +0.7982\n  zpve                      \u2194 U0                         r = +0.7758\n  polarizability            \u2194 zpve                       r = +0.7655\n  polarizability            \u2194 electronic_spatial_extent  r = +0.7170\n  LUMO                      \u2194 zpve                       r = +0.6705\n  gap                       \u2194 zpve                       r = +0.5705\n  electronic_spatial_extent \u2194 zpve                       r = +0.5284\n\n\u2705 Zapisano: qm9_top_correlations.png\n</pre> <pre>\n======================================================================\n3. ANALIZA HOMO-LUMO-GAP\n======================================================================\n\n\ud83d\udcca Korelacje z HOMO-LUMO gap:\n----------------------------------------------------------------------\n  LUMO                            r = +0.8670\n  zpve                            r = +0.5705\n  G                               r = +0.3873\n  H                               r = +0.3873\n  U                               r = +0.3873\n  Cv                              r = +0.3873\n  U0                              r = +0.2404\n  polarizability                  r = +0.1883\n  electronic_spatial_extent       r = +0.0438\n  HOMO                            r = -0.2878\n  dipole_moment                   r = -0.3407\n\n\u2705 Zapisano: qm9_homo_lumo_gap.png\n</pre> <pre>\n======================================================================\n4. PAIRPLOT - KLUCZOWE W\u0141A\u015aCIWO\u015aCI\n======================================================================\n\n\ud83d\udcc8 Tworzenie pairplot dla 5 w\u0142a\u015bciwo\u015bci...\n   U\u017cywam 1000 pr\u00f3bek dla szybszej wizualizacji\n\u2705 Zapisano: qm9_pairplot.png\n</pre> <pre>\n======================================================================\n5. POR\u00d3WNANIE KORELACJI PEARSONA vs SPEARMANA\n======================================================================\n\n\ud83d\udcca Najwi\u0119ksze r\u00f3\u017cnice mi\u0119dzy Pearson a Spearman (nieliniowo\u015bci):\n----------------------------------------------------------------------\n  polarizability       \u2194 H                   \n    Pearson: -0.1031  |  Spearman: +0.1497  |  Diff: 0.2528\n  polarizability       \u2194 G                   \n    Pearson: -0.1031  |  Spearman: +0.1497  |  Diff: 0.2528\n  polarizability       \u2194 U                   \n    Pearson: -0.1031  |  Spearman: +0.1496  |  Diff: 0.2527\n  polarizability       \u2194 Cv                  \n    Pearson: -0.1031  |  Spearman: +0.1495  |  Diff: 0.2526\n  U0                   \u2194 H                   \n    Pearson: -0.3127  |  Spearman: -0.1948  |  Diff: 0.1179\n  U0                   \u2194 G                   \n    Pearson: -0.3127  |  Spearman: -0.1948  |  Diff: 0.1179\n  U0                   \u2194 U                   \n    Pearson: -0.3127  |  Spearman: -0.1950  |  Diff: 0.1177\n  U0                   \u2194 Cv                  \n    Pearson: -0.3128  |  Spearman: -0.1953  |  Diff: 0.1175\n  polarizability       \u2194 gap                 \n    Pearson: +0.1883  |  Spearman: +0.2940  |  Diff: 0.1057\n  HOMO                 \u2194 U0                  \n    Pearson: +0.1213  |  Spearman: +0.0184  |  Diff: 0.1028\n\n======================================================================\n6. PODSUMOWANIE ANALIZY KORELACJI\n======================================================================\n\n\ud83d\udcca STATYSTYKI KORELACJI:\n\n\u2022 Liczba analizowanych w\u0142a\u015bciwo\u015bci: 12\n\u2022 Liczba par korelacji: 66\n\n\u2022 Najsilniejsza korelacja dodatnia:\n  H \u2194 G\n  r = 1.0000\n\n\u2022 Najsilniejsza korelacja ujemna:\n  dipole_moment \u2194 LUMO\n  r = -0.3941\n\n\u2022 Silne korelacje (|r| &gt; 0.7): 12\n\u2022 \u015arednie korelacje (0.3 &lt; |r| &lt; 0.7): 24\n\u2022 S\u0142abe korelacje (|r| &lt; 0.3): 30\n\n======================================================================\n\u2705 ANALIZA KORELACJI ZAKO\u0143CZONA!\n   Wygenerowano 4 pliki PNG z wizualizacjami\n======================================================================\n</pre> In\u00a0[13]: <pre># ============================================================\n# KOM\u00d3RKA 7: WALIDACJA I ANALIZA STRUKTUR SMILES\n# ============================================================\n\nfrom rdkit import Chem, RDLogger\nfrom rdkit.Chem import Descriptors, rdMolDescriptors\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom collections import Counter\n\n# Wyciszenie ostrze\u017ce\u0144 RDKit\nRDLogger.DisableLog('rdApp.*')\n\nprint(\"=\"*70)\nprint(\"WALIDACJA STRUKTUR SMILES - QM9 DATASET\")\nprint(\"=\"*70)\n\n# ============================================================\n# 1. PODSTAWOWA WALIDACJA SMILES\n# ============================================================\n\nprint(\"\\n\ud83d\udccb ETAP 1: PODSTAWOWA WALIDACJA\")\nprint(\"-\" * 70)\n\ndef validate_smiles_detailed(smiles):\n    \"\"\"\n    Szczeg\u00f3\u0142owa walidacja SMILES z diagnoz\u0105 b\u0142\u0119d\u00f3w\n    \n    Returns:\n        dict: {'valid': bool, 'error': str, 'mol': Mol object}\n    \"\"\"\n    try:\n        mol = Chem.MolFromSmiles(smiles)\n        if mol is None:\n            return {'valid': False, 'error': 'Parse Error', 'mol': None}\n\n        # Pr\u00f3ba sanityzacji\n        Chem.SanitizeMol(mol)\n        return {'valid': True, 'error': None, 'mol': mol}\n\n    except Exception as e:\n        error_type = str(e).split(':')[0] if ':' in str(e) else str(e)\n        return {'valid': False, 'error': error_type, 'mol': None}\n\n# Walidacja wszystkich SMILES\nprint(\"Walidacja struktur SMILES...\")\nvalidation_results = df['SMILES'].apply(validate_smiles_detailed)\n\ndf['is_valid'] = validation_results.apply(lambda x: x['valid'])\ndf['error_type'] = validation_results.apply(lambda x: x['error'])\n\n# Statystyki\ntotal_smiles = len(df)\nvalid_smiles = df['is_valid'].sum()\ninvalid_smiles = total_smiles - valid_smiles\nvalidity_pct = (valid_smiles / total_smiles) * 100\n\nprint(f\"\\n\u2705 Poprawne SMILES: {valid_smiles:,} ({validity_pct:.2f}%)\")\nprint(f\"\u274c Niepoprawne SMILES: {invalid_smiles:,} ({(100-validity_pct):.2f}%)\")\n\n# ============================================================\n# 2. ANALIZA B\u0141\u0118D\u00d3W WALIDACJI\n# ============================================================\n\nif invalid_smiles &gt; 0:\n    print(\"\\n\" + \"=\"*70)\n    print(\"\ud83d\udcca ANALIZA B\u0141\u0118D\u00d3W WALIDACJI\")\n    print(\"=\"*70)\n\n    # Typy b\u0142\u0119d\u00f3w\n    error_counts = df[~df['is_valid']]['error_type'].value_counts()\n\n    print(\"\\n\ud83d\udd0d Typy b\u0142\u0119d\u00f3w walidacji:\")\n    for error, count in error_counts.items():\n        pct = (count / invalid_smiles) * 100\n        print(f\"  \u2022 {error:40s}  {count:5d} ({pct:5.2f}%)\")\n\n    # Przyk\u0142ady b\u0142\u0119dnych SMILES\n    print(\"\\n\u26a0\ufe0f  Przyk\u0142ady niepoprawnych SMILES:\")\n    invalid_samples = df[~df['is_valid']].head(10)\n    for idx, row in invalid_samples.iterrows():\n        print(f\"\\n  [{idx}] {row['SMILES'][:60]}{'...' if len(row['SMILES']) &gt; 60 else ''}\")\n        print(f\"      B\u0142\u0105d: {row['error_type']}\")\n\n    # Wizualizacja typ\u00f3w b\u0142\u0119d\u00f3w\n    if len(error_counts) &gt; 0:\n        plt.figure(figsize=(12, 6))\n        colors = plt.cm.Reds(np.linspace(0.4, 0.8, len(error_counts)))\n        plt.barh(range(len(error_counts)), error_counts.values, color=colors, edgecolor='black')\n        plt.yticks(range(len(error_counts)), error_counts.index)\n        plt.xlabel('Liczba wyst\u0105pie\u0144', fontsize=12, fontweight='bold')\n        plt.title('Typy b\u0142\u0119d\u00f3w walidacji SMILES', fontsize=14, fontweight='bold')\n        plt.grid(axis='x', alpha=0.3)\n\n        for i, val in enumerate(error_counts.values):\n            plt.text(val + max(error_counts.values)*0.01, i, f'{val}', \n                    va='center', fontweight='bold')\n\n        plt.tight_layout()\n        plt.savefig('qm9_smiles_errors.png', dpi=300, bbox_inches='tight')\n        print(\"\\n\u2705 Zapisano: qm9_smiles_errors.png\")\n        plt.show()\n\nelse:\n    print(\"\\n\u2705 WSZYSTKIE SMILES S\u0104 POPRAWNE! Dataset QM9 ma 100% validacj\u0119.\")\n\n# ============================================================\n# 3. ANALIZA SK\u0141ADU CHEMICZNEGO\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83e\uddea ANALIZA SK\u0141ADU CHEMICZNEGO\")\nprint(\"=\"*70)\n\n# Tylko dla poprawnych SMILES\ndf_valid = df[df['is_valid']].copy()\n\ndef analyze_composition(smiles):\n    \"\"\"Analiza sk\u0142adu atomowego cz\u0105steczki\"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n\n    atoms = [atom.GetSymbol() for atom in mol.GetAtoms()]\n    return Counter(atoms)\n\nprint(\"\\nAnalizuj\u0119 sk\u0142ad atomowy cz\u0105steczek...\")\ncompositions = df_valid['SMILES'].apply(analyze_composition)\n\n# Ekstrakcja wszystkich typ\u00f3w atom\u00f3w\nall_atoms = []\nfor comp in compositions.dropna():\n    all_atoms.extend(comp.keys())\n\natom_types = Counter(all_atoms)\n\nprint(f\"\\n\ud83d\udcca Typy atom\u00f3w wyst\u0119puj\u0105ce w datasecie ({len(atom_types)}):\")\nfor atom, count in atom_types.most_common():\n    pct = (count / len(df_valid)) * 100\n    print(f\"  \u2022 {atom:3s}  wyst\u0119puje w {count:6,} cz\u0105steczkach ({pct:5.2f}%)\")\n\n# Rozk\u0142ad liczby atom\u00f3w per typ\natom_counts = {atom: [] for atom in atom_types.keys()}\nfor comp in compositions.dropna():\n    for atom in atom_types.keys():\n        atom_counts[atom].append(comp.get(atom, 0))\n\n# Konwersja do DataFrame\ndf_atoms = pd.DataFrame(atom_counts)\n\nprint(f\"\\n\ud83d\udcc8 Statystyki liczby atom\u00f3w:\")\nprint(df_atoms.describe())\n\n# ============================================================\n# 4. WIZUALIZACJA SK\u0141ADU ATOMOWEGO\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udcca WIZUALIZACJA SK\u0141ADU ATOMOWEGO\")\nprint(\"=\"*70)\n\n# Wykresy dla g\u0142\u00f3wnych atom\u00f3w (H, C, N, O, F)\nmain_atoms = ['H', 'C', 'N', 'O', 'F']\nmain_atoms = [atom for atom in main_atoms if atom in df_atoms.columns]\n\nfig, axes = plt.subplots(2, 3, figsize=(18, 10))\naxes = axes.flatten()\n\nfor i, atom in enumerate(main_atoms):\n    if atom in df_atoms.columns:\n        data = df_atoms[atom]\n        axes[i].hist(data, bins=50, color='steelblue', edgecolor='black', alpha=0.7)\n        axes[i].set_xlabel(f'Liczba atom\u00f3w {atom}', fontsize=11, fontweight='bold')\n        axes[i].set_ylabel('Liczba cz\u0105steczek', fontsize=11, fontweight='bold')\n        axes[i].set_title(f'Rozk\u0142ad atom\u00f3w {atom}\\n\u015arednia: {data.mean():.1f}, Max: {data.max():.0f}', \n                         fontsize=12, fontweight='bold')\n        axes[i].grid(axis='y', alpha=0.3)\n\n# Wykres por\u00f3wnawczy - \u015brednie liczby atom\u00f3w\nif len(main_atoms) &lt; 6:\n    ax_comparison = axes[5]\n    means = [df_atoms[atom].mean() for atom in main_atoms]\n    colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'][:len(main_atoms)]\n    bars = ax_comparison.bar(main_atoms, means, color=colors, edgecolor='black', linewidth=1.5)\n    ax_comparison.set_ylabel('\u015arednia liczba atom\u00f3w', fontsize=11, fontweight='bold')\n    ax_comparison.set_title('\u015aredni sk\u0142ad atomowy cz\u0105steczek QM9', fontsize=12, fontweight='bold')\n    ax_comparison.grid(axis='y', alpha=0.3)\n\n    for bar, val in zip(bars, means):\n        ax_comparison.text(bar.get_x() + bar.get_width()/2, val + 0.1, \n                          f'{val:.1f}', ha='center', fontweight='bold')\n\nplt.tight_layout()\nplt.savefig('qm9_atomic_composition.png', dpi=300, bbox_inches='tight')\nprint(\"\u2705 Zapisano: qm9_atomic_composition.png\")\nplt.show()\n\n# ============================================================\n# 5. ANALIZA W\u0141A\u015aCIWO\u015aCI MOLEKULARNYCH (RDKit)\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\u2697\ufe0f OBLICZANIE DESKRYPTOR\u00d3W MOLEKULARNYCH\")\nprint(\"=\"*70)\n\ndef calculate_rdkit_descriptors(smiles):\n    \"\"\"Oblicza podstawowe deskryptory RDKit\"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n\n    try:\n        return {\n            'MolWt': Descriptors.MolWt(mol),\n            'NumAtoms': mol.GetNumAtoms(),\n            'NumHeavyAtoms': mol.GetNumHeavyAtoms(),\n            'NumHeteroatoms': rdMolDescriptors.CalcNumHeteroatoms(mol),\n            'NumRotatableBonds': rdMolDescriptors.CalcNumRotatableBonds(mol),\n            'NumHBD': rdMolDescriptors.CalcNumHBD(mol),\n            'NumHBA': rdMolDescriptors.CalcNumHBA(mol),\n            'NumRings': rdMolDescriptors.CalcNumRings(mol),\n            'NumAromaticRings': rdMolDescriptors.CalcNumAromaticRings(mol),\n            'TPSA': Descriptors.TPSA(mol),\n            'LogP': Descriptors.MolLogP(mol),\n            'FractionCSP3': rdMolDescriptors.CalcFractionCsp3(mol)\n        }\n    except:\n        return None\n\nprint(\"Obliczam deskryptory RDKit dla poprawnych struktur...\")\ndescriptors = df_valid['SMILES'].apply(calculate_rdkit_descriptors)\ndf_descriptors = descriptors.apply(pd.Series)\n\n# Sprawdzenie czy s\u0105 jakiekolwiek dane\nif df_descriptors.empty or df_descriptors.shape[1] == 0:\n    print(\"\\n\u26a0\ufe0f  BRAK POPRAWNYCH STRUKTUR DO ANALIZY!\")\n    print(\"   Wszystkie SMILES s\u0105 niepoprawne lub nie mo\u017cna obliczy\u0107 deskryptor\u00f3w.\")\nelse:\n    # Dodanie do g\u0142\u00f3wnego DataFrame\n    df_valid = pd.concat([df_valid.reset_index(drop=True), \n                          df_descriptors.reset_index(drop=True)], axis=1)\n\n    print(f\"\u2705 Obliczono {len(df_descriptors.columns)} deskryptor\u00f3w dla {len(df_valid)} struktur\")\n\n    print(\"\\n\ud83d\udcca Statystyki deskryptor\u00f3w molekularnych:\")\n    print(df_descriptors.describe())\n\n# ============================================================\n# 6. CHARAKTERYSTYKA DATASETU QM9\n# ============================================================\n\nif not df_descriptors.empty and df_descriptors.shape[1] &gt; 0:\n    print(\"\\n\" + \"=\"*70)\n    print(\"\ud83d\udccb CHARAKTERYSTYKA DATASETU QM9\")\n    print(\"=\"*70)\n\n    print(f\"\"\"\n\ud83d\udd2c SK\u0141AD CHEMICZNY:\n  \u2022 Dozwolone atomy: {', '.join(sorted(atom_types.keys()))}\n  \u2022 Najcz\u0119stsze atomy: H, C, N, O, F (QM9 spec)\n  \u2022 \u015arednia liczba atom\u00f3w: {df_descriptors['NumAtoms'].mean():.1f}\n  \u2022 \u015arednia liczba ci\u0119\u017ckich atom\u00f3w: {df_descriptors['NumHeavyAtoms'].mean():.1f}\n  \u2022 Max ci\u0119\u017ckich atom\u00f3w: {df_descriptors['NumHeavyAtoms'].max():.0f} (limit QM9: 9)\n\n\ud83d\udccf ROZMIAR MOLEKU\u0141:\n  \u2022 Masa molowa: {df_descriptors['MolWt'].mean():.1f} \u00b1 {df_descriptors['MolWt'].std():.1f} g/mol\n  \u2022 Zakres: {df_descriptors['MolWt'].min():.1f} - {df_descriptors['MolWt'].max():.1f} g/mol\n\n\ud83d\udd17 STRUKTURY:\n  \u2022 \u015arednia liczba pier\u015bcieni: {df_descriptors['NumRings'].mean():.2f}\n  \u2022 Cz\u0105steczki aromatyczne: {(df_descriptors['NumAromaticRings'] &gt; 0).sum():,} ({(df_descriptors['NumAromaticRings'] &gt; 0).sum()/len(df_descriptors)*100:.1f}%)\n  \u2022 \u015arednia rotowalne wi\u0105zania: {df_descriptors['NumRotatableBonds'].mean():.2f}\n\n\ud83d\udca7 W\u0141A\u015aCIWO\u015aCI FIZYKOCHEMICZNE:\n  \u2022 \u015arednie LogP: {df_descriptors['LogP'].mean():.2f} \u00b1 {df_descriptors['LogP'].std():.2f}\n  \u2022 \u015arednie TPSA: {df_descriptors['TPSA'].mean():.1f} \u0172\n  \u2022 \u015arednia frakcja sp3: {df_descriptors['FractionCSP3'].mean():.2f}\n\n\u2705 JAKO\u015a\u0106 DANYCH:\n  \u2022 Validacja SMILES: {validity_pct:.2f}%\n  \u2022 Kompletno\u015b\u0107: {(df['is_valid'].sum() / len(df) * 100):.2f}%\n  \u2022 B\u0142\u0119dne struktury: {invalid_smiles:,}\n\"\"\")\n\n# ============================================================\n# 7. WIZUALIZACJA POR\u00d3WNAWCZA\n# ============================================================\n\nif not df_descriptors.empty and df_descriptors.shape[1] &gt; 0:\n    print(\"\\n\" + \"=\"*70)\n    print(\"\ud83d\udcca WIZUALIZACJA W\u0141A\u015aCIWO\u015aCI MOLEKULARNYCH\")\n    print(\"=\"*70)\n\n    fig, axes = plt.subplots(2, 3, figsize=(18, 10))\n\n    # 1. Masa molowa\n    axes[0, 0].hist(df_descriptors['MolWt'], bins=50, color='#3498db', \n                    edgecolor='black', alpha=0.7)\n    axes[0, 0].set_xlabel('Masa molowa (g/mol)', fontweight='bold')\n    axes[0, 0].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[0, 0].set_title('Rozk\u0142ad masy molowej', fontweight='bold', fontsize=12)\n    axes[0, 0].grid(axis='y', alpha=0.3)\n\n    # 2. Liczba ci\u0119\u017ckich atom\u00f3w\n    axes[0, 1].hist(df_descriptors['NumHeavyAtoms'], bins=range(1, 11), \n                    color='#e74c3c', edgecolor='black', alpha=0.7)\n    axes[0, 1].set_xlabel('Liczba ci\u0119\u017ckich atom\u00f3w', fontweight='bold')\n    axes[0, 1].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[0, 1].set_title('Rozk\u0142ad liczby ci\u0119\u017ckich atom\u00f3w (max=9)', fontweight='bold', fontsize=12)\n    axes[0, 1].grid(axis='y', alpha=0.3)\n\n    # 3. LogP\n    axes[0, 2].hist(df_descriptors['LogP'], bins=50, color='#2ecc71', \n                    edgecolor='black', alpha=0.7)\n    axes[0, 2].set_xlabel('LogP', fontweight='bold')\n    axes[0, 2].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[0, 2].set_title('Rozk\u0142ad lipofilowo\u015bci (LogP)', fontweight='bold', fontsize=12)\n    axes[0, 2].grid(axis='y', alpha=0.3)\n\n    # 4. TPSA\n    axes[1, 0].hist(df_descriptors['TPSA'], bins=50, color='#f39c12', \n                    edgecolor='black', alpha=0.7)\n    axes[1, 0].set_xlabel('TPSA (\u0172)', fontweight='bold')\n    axes[1, 0].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[1, 0].set_title('Rozk\u0142ad polarnej powierzchni (TPSA)', fontweight='bold', fontsize=12)\n    axes[1, 0].grid(axis='y', alpha=0.3)\n\n    # 5. Liczba pier\u015bcieni\n    ring_counts = df_descriptors['NumRings'].value_counts().sort_index()\n    axes[1, 1].bar(ring_counts.index, ring_counts.values, color='#9b59b6', \n                   edgecolor='black', alpha=0.7)\n    axes[1, 1].set_xlabel('Liczba pier\u015bcieni', fontweight='bold')\n    axes[1, 1].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[1, 1].set_title('Rozk\u0142ad liczby pier\u015bcieni', fontweight='bold', fontsize=12)\n    axes[1, 1].grid(axis='y', alpha=0.3)\n\n    # 6. Frakcja sp3\n    axes[1, 2].hist(df_descriptors['FractionCSP3'], bins=50, color='#1abc9c', \n                    edgecolor='black', alpha=0.7)\n    axes[1, 2].set_xlabel('Frakcja w\u0119gli sp\u00b3', fontweight='bold')\n    axes[1, 2].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[1, 2].set_title('Rozk\u0142ad frakcji sp\u00b3 (saturacja)', fontweight='bold', fontsize=12)\n    axes[1, 2].grid(axis='y', alpha=0.3)\n\n    plt.suptitle('W\u0142a\u015bciwo\u015bci molekularne datasetu QM9', fontsize=16, fontweight='bold', y=1.00)\n    plt.tight_layout()\n    plt.savefig('qm9_molecular_properties.png', dpi=300, bbox_inches='tight')\n    print(\"\u2705 Zapisano: qm9_molecular_properties.png\")\n    plt.show()\nelse:\n    print(\"\\n\u26a0\ufe0f  Brak danych do wizualizacji w\u0142a\u015bciwo\u015bci molekularnych\")\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\u2705 WALIDACJA I ANALIZA SMILES ZAKO\u0143CZONA!\")\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nWALIDACJA STRUKTUR SMILES - QM9 DATASET\n======================================================================\n\n\ud83d\udccb ETAP 1: PODSTAWOWA WALIDACJA\n----------------------------------------------------------------------\nWalidacja struktur SMILES...\n\n\u2705 Poprawne SMILES: 1,000 (100.00%)\n\u274c Niepoprawne SMILES: 0 (0.00%)\n\n\u2705 WSZYSTKIE SMILES S\u0104 POPRAWNE! Dataset QM9 ma 100% validacj\u0119.\n\n======================================================================\n\ud83e\uddea ANALIZA SK\u0141ADU CHEMICZNEGO\n======================================================================\n\nAnalizuj\u0119 sk\u0142ad atomowy cz\u0105steczek...\n\n\ud83d\udcca Typy atom\u00f3w wyst\u0119puj\u0105ce w datasecie (5):\n  \u2022 C    wyst\u0119puje w  1,000 cz\u0105steczkach (100.00%)\n  \u2022 O    wyst\u0119puje w    843 cz\u0105steczkach (84.30%)\n  \u2022 N    wyst\u0119puje w    622 cz\u0105steczkach (62.20%)\n  \u2022 H    wyst\u0119puje w     16 cz\u0105steczkach ( 1.60%)\n  \u2022 F    wyst\u0119puje w     14 cz\u0105steczkach ( 1.40%)\n\n\ud83d\udcc8 Statystyki liczby atom\u00f3w:\n                 C            N            O            H            F\ncount  1000.000000  1000.000000  1000.000000  1000.000000  1000.000000\nmean      6.251000     1.093000     1.392000     0.017000     0.020000\nstd       1.282046     1.138265     0.875844     0.136857     0.188774\nmin       2.000000     0.000000     0.000000     0.000000     0.000000\n25%       5.000000     0.000000     1.000000     0.000000     0.000000\n50%       6.000000     1.000000     1.000000     0.000000     0.000000\n75%       7.000000     2.000000     2.000000     0.000000     0.000000\nmax       9.000000     6.000000     4.000000     2.000000     3.000000\n\n======================================================================\n\ud83d\udcca WIZUALIZACJA SK\u0141ADU ATOMOWEGO\n======================================================================\n\u2705 Zapisano: qm9_atomic_composition.png\n</pre> <pre>\n======================================================================\n\u2697\ufe0f OBLICZANIE DESKRYPTOR\u00d3W MOLEKULARNYCH\n======================================================================\nObliczam deskryptory RDKit dla poprawnych struktur...\n\n\u26a0\ufe0f  BRAK POPRAWNYCH STRUKTUR DO ANALIZY!\n   Wszystkie SMILES s\u0105 niepoprawne lub nie mo\u017cna obliczy\u0107 deskryptor\u00f3w.\n\n\u26a0\ufe0f  Brak danych do wizualizacji w\u0142a\u015bciwo\u015bci molekularnych\n\n======================================================================\n\u2705 WALIDACJA I ANALIZA SMILES ZAKO\u0143CZONA!\n======================================================================\n</pre> In\u00a0[14]: <pre># debudding\n</pre> In\u00a0[15]: <pre># ============================================================\n# DEBUGGING - SPRAWDZENIE KOLUMNY SMILES\n# ============================================================\n\nprint(\"=\"*70)\nprint(\"\ud83d\udd0d DEBUGGING - ANALIZA KOLUMNY SMILES\")\nprint(\"=\"*70)\n\n# 1. Sprawd\u017a nazwy kolumn\nprint(\"\\n1\ufe0f\u20e3 Kolumny w DataFrame:\")\nprint(df.columns.tolist())\n\n# 2. Sprawd\u017a czy kolumna SMILES istnieje\nprint(f\"\\n2\ufe0f\u20e3 Czy 'SMILES' w kolumnach? {('SMILES' in df.columns)}\")\n\n# 3. Je\u015bli istnieje, poka\u017c przyk\u0142ady\nif 'SMILES' in df.columns:\n    print(\"\\n3\ufe0f\u20e3 Pierwsze 10 warto\u015bci w kolumnie SMILES:\")\n    for i, smiles in enumerate(df['SMILES'].head(10), 1):\n        print(f\"  {i:2d}. {smiles}\")\n\n    # 4. Typ danych\n    print(f\"\\n4\ufe0f\u20e3 Typ danych kolumny SMILES: {df['SMILES'].dtype}\")\n\n    # 5. D\u0142ugo\u015b\u0107 SMILES\n    print(f\"\\n5\ufe0f\u20e3 Statystyki d\u0142ugo\u015bci SMILES:\")\n    smiles_lengths = df['SMILES'].astype(str).str.len()\n    print(f\"  Min: {smiles_lengths.min()}\")\n    print(f\"  Max: {smiles_lengths.max()}\")\n    print(f\"  \u015arednia: {smiles_lengths.mean():.1f}\")\n\n    # 6. Czy s\u0105 puste warto\u015bci?\n    print(f\"\\n6\ufe0f\u20e3 Puste/NaN warto\u015bci: {df['SMILES'].isna().sum()}\")\n\n    # 7. Test walidacji pojedynczego SMILES\n    print(\"\\n7\ufe0f\u20e3 Test walidacji pojedynczego SMILES:\")\n    test_smiles = df['SMILES'].iloc[0]\n    print(f\"  SMILES: {test_smiles}\")\n    print(f\"  Typ: {type(test_smiles)}\")\n\n    from rdkit import Chem\n    mol = Chem.MolFromSmiles(str(test_smiles))\n    if mol is None:\n        print(f\"  \u274c RDKit NIE MO\u017bE SPARSOWA\u0106!\")\n    else:\n        print(f\"  \u2705 RDKit sparsowa\u0142 poprawnie\")\n        print(f\"  Liczba atom\u00f3w: {mol.GetNumAtoms()}\")\n\nelse:\n    print(\"\\n\u274c KOLUMNA 'SMILES' NIE ISTNIEJE!\")\n    print(\"\\nMo\u017cliwe alternatywne nazwy:\")\n    for col in df.columns:\n        if 'smile' in col.lower() or 'mol' in col.lower() or 'id' in col.lower():\n            print(f\"  \u2022 {col}\")\n\nprint(\"\\n\" + \"=\"*70)\n</pre> <pre>======================================================================\n\ud83d\udd0d DEBUGGING - ANALIZA KOLUMNY SMILES\n======================================================================\n\n1\ufe0f\u20e3 Kolumny w DataFrame:\n['dipole_moment', 'polarizability', 'HOMO', 'LUMO', 'gap', 'electronic_spatial_extent', 'zpve', 'U0', 'U', 'H', 'G', 'Cv', 'SMILES', 'dataset_split', 'num_atoms', 'is_valid', 'error_type']\n\n2\ufe0f\u20e3 Czy 'SMILES' w kolumnach? True\n\n3\ufe0f\u20e3 Pierwsze 10 warto\u015bci w kolumnie SMILES:\n   1. [H]C([H])([H])C([H])([H])[N@@H+]1C([H])([H])[C@]1(C([H])([H])[H])C([H])([H])C([H])([H])C([H])([H])[H]\n   2. [H]O[C@@]12C([H])([H])O[C@]1([H])[C@]2([H])[C@]([H])(O[H])C([H])([H])[H]\n   3. [H]C1([H])C([H])([H])[C@]2([H])[C@@]1([H])[C@]1([H])OC([H])([H])[C@@]12C([H])([H])[H]\n   4. [H]OC([H])([H])[C@]1(C([H])([H])C#N)OC1([H])[H]\n   5. [H]N1[C@]2([H])C(=O)[C@@]1([H])C([H])([H])OC2([H])[H]\n   6. [H][N-]C1OC([H])([H])[C@]12[N@@H+]1C([H])([H])[C@]1([H])C2([H])[H]\n   7. [H]N([H])C1[NH2+][C@]2([H])C([H])([H])[C@]2(C([H])([H])C([H])([H])[H])O1\n   8. [H]C1([H])[N@@H+]2[C@@]3([H])[C@]2([H])[C@@]2([H])C([H])([H])[C@]1([H])[C@@]32[H]\n   9. [H]C([H])([H])O[C@@]1(C([H])([H])[H])C([H])([H])[C@@]2([H])[C@@]([H])(C([H])([H])[H])[C@@]12[H]\n  10. [H]C(=O)c1c([H])c(N([H])[H])nn1[H]\n\n4\ufe0f\u20e3 Typ danych kolumny SMILES: object\n\n5\ufe0f\u20e3 Statystyki d\u0142ugo\u015bci SMILES:\n  Min: 13\n  Max: 101\n  \u015arednia: 62.8\n\n6\ufe0f\u20e3 Puste/NaN warto\u015bci: 0\n\n7\ufe0f\u20e3 Test walidacji pojedynczego SMILES:\n  SMILES: [H]C([H])([H])C([H])([H])[N@@H+]1C([H])([H])[C@]1(C([H])([H])[H])C([H])([H])C([H])([H])C([H])([H])[H]\n  Typ: &lt;class 'str'&gt;\n  \u2705 RDKit sparsowa\u0142 poprawnie\n  Liczba atom\u00f3w: 9\n\n======================================================================\n</pre> <p>SMILES s\u0105 poprawne, ale maj\u0105 jawne atomy wodoru [H] i sterochemi\u0119 [C@], [C@@] - to s\u0105 bardzo szczeg\u00f3\u0142owe SMILES z QM9! Problem jest w poprzednim kodzie - prawdopodobnie kolumny is_valid i error_type ju\u017c istniej\u0105 z poprzedniego uruchomienia i nadpisuj\u0105 nowe wyniki. Rozwi\u0105zanie: Usu\u0144my te kolumny przed walidacj\u0105:</p> In\u00a0[16]: <pre># ============================================================\n# KOM\u00d3RKA 7: WALIDACJA I ANALIZA STRUKTUR SMILES\n# ============================================================\n\nfrom rdkit import Chem, RDLogger\nfrom rdkit.Chem import Descriptors, rdMolDescriptors\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom collections import Counter\n\n# Wyciszenie ostrze\u017ce\u0144 RDKit\nRDLogger.DisableLog('rdApp.*')\n\nprint(\"=\"*70)\nprint(\"WALIDACJA STRUKTUR SMILES - QM9 DATASET\")\nprint(\"=\"*70)\n\n# ============================================================\n# 1. PODSTAWOWA WALIDACJA SMILES\n# ============================================================\n\nprint(\"\\n\ud83d\udccb ETAP 1: PODSTAWOWA WALIDACJA\")\nprint(\"-\" * 70)\n\n# Usuni\u0119cie starych kolumn walidacji je\u015bli istniej\u0105\nif 'is_valid' in df.columns:\n    df = df.drop(columns=['is_valid'])\nif 'error_type' in df.columns:\n    df = df.drop(columns=['error_type'])\n\ndef validate_smiles_detailed(smiles):\n    \"\"\"\n    Szczeg\u00f3\u0142owa walidacja SMILES z diagnoz\u0105 b\u0142\u0119d\u00f3w\n    \n    Returns:\n        dict: {'valid': bool, 'error': str, 'mol': Mol object}\n    \"\"\"\n    try:\n        mol = Chem.MolFromSmiles(smiles)\n        if mol is None:\n            return {'valid': False, 'error': 'Parse Error', 'mol': None}\n\n        # Pr\u00f3ba sanityzacji\n        Chem.SanitizeMol(mol)\n        return {'valid': True, 'error': None, 'mol': mol}\n\n    except Exception as e:\n        error_type = str(e).split(':')[0] if ':' in str(e) else str(e)\n        return {'valid': False, 'error': error_type, 'mol': None}\n\n# Walidacja wszystkich SMILES\nprint(\"Walidacja struktur SMILES...\")\nprint(f\"Przyk\u0142adowe SMILES do walidacji:\")\nprint(df['SMILES'].head(5).tolist())\n\nvalidation_results = df['SMILES'].apply(validate_smiles_detailed)\n\ndf['is_valid'] = validation_results.apply(lambda x: x['valid'])\ndf['error_type'] = validation_results.apply(lambda x: x['error'])\n\n# Statystyki\ntotal_smiles = len(df)\nvalid_smiles = df['is_valid'].sum()\ninvalid_smiles = total_smiles - valid_smiles\nvalidity_pct = (valid_smiles / total_smiles) * 100\n\nprint(f\"\\n\u2705 Poprawne SMILES: {valid_smiles:,} ({validity_pct:.2f}%)\")\nprint(f\"\u274c Niepoprawne SMILES: {invalid_smiles:,} ({(100-validity_pct):.2f}%)\")\n\n# Debug - poka\u017c przyk\u0142ady\nif valid_smiles &gt; 0:\n    print(f\"\\n\u2713 Przyk\u0142ady POPRAWNYCH SMILES:\")\n    print(df[df['is_valid']]['SMILES'].head(3).tolist())\nif invalid_smiles &gt; 0:\n    print(f\"\\n\u2717 Przyk\u0142ady NIEPOPRAWNYCH SMILES:\")\n    print(df[~df['is_valid']]['SMILES'].head(3).tolist())\n\n# ============================================================\n# 2. ANALIZA B\u0141\u0118D\u00d3W WALIDACJI\n# ============================================================\n\nif invalid_smiles &gt; 0:\n    print(\"\\n\" + \"=\"*70)\n    print(\"\ud83d\udcca ANALIZA B\u0141\u0118D\u00d3W WALIDACJI\")\n    print(\"=\"*70)\n\n    # Typy b\u0142\u0119d\u00f3w\n    error_counts = df[~df['is_valid']]['error_type'].value_counts()\n\n    print(\"\\n\ud83d\udd0d Typy b\u0142\u0119d\u00f3w walidacji:\")\n    for error, count in error_counts.items():\n        pct = (count / invalid_smiles) * 100\n        print(f\"  \u2022 {error:40s}  {count:5d} ({pct:5.2f}%)\")\n\n    # Przyk\u0142ady b\u0142\u0119dnych SMILES\n    print(\"\\n\u26a0\ufe0f  Przyk\u0142ady niepoprawnych SMILES:\")\n    invalid_samples = df[~df['is_valid']].head(10)\n    for idx, row in invalid_samples.iterrows():\n        print(f\"\\n  [{idx}] {row['SMILES'][:60]}{'...' if len(row['SMILES']) &gt; 60 else ''}\")\n        print(f\"      B\u0142\u0105d: {row['error_type']}\")\n\n    # Wizualizacja typ\u00f3w b\u0142\u0119d\u00f3w\n    if len(error_counts) &gt; 0:\n        plt.figure(figsize=(12, 6))\n        colors = plt.cm.Reds(np.linspace(0.4, 0.8, len(error_counts)))\n        plt.barh(range(len(error_counts)), error_counts.values, color=colors, edgecolor='black')\n        plt.yticks(range(len(error_counts)), error_counts.index)\n        plt.xlabel('Liczba wyst\u0105pie\u0144', fontsize=12, fontweight='bold')\n        plt.title('Typy b\u0142\u0119d\u00f3w walidacji SMILES', fontsize=14, fontweight='bold')\n        plt.grid(axis='x', alpha=0.3)\n\n        for i, val in enumerate(error_counts.values):\n            plt.text(val + max(error_counts.values)*0.01, i, f'{val}', \n                    va='center', fontweight='bold')\n\n        plt.tight_layout()\n        plt.savefig('qm9_smiles_errors.png', dpi=300, bbox_inches='tight')\n        print(\"\\n\u2705 Zapisano: qm9_smiles_errors.png\")\n        plt.show()\n\nelse:\n    print(\"\\n\u2705 WSZYSTKIE SMILES S\u0104 POPRAWNE! Dataset QM9 ma 100% validacj\u0119.\")\n\n# ============================================================\n# 3. ANALIZA SK\u0141ADU CHEMICZNEGO\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83e\uddea ANALIZA SK\u0141ADU CHEMICZNEGO\")\nprint(\"=\"*70)\n\n# Tylko dla poprawnych SMILES\ndf_valid = df[df['is_valid']].copy()\n\ndef analyze_composition(smiles):\n    \"\"\"Analiza sk\u0142adu atomowego cz\u0105steczki\"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n\n    atoms = [atom.GetSymbol() for atom in mol.GetAtoms()]\n    return Counter(atoms)\n\nprint(\"\\nAnalizuj\u0119 sk\u0142ad atomowy cz\u0105steczek...\")\ncompositions = df_valid['SMILES'].apply(analyze_composition)\n\n# Ekstrakcja wszystkich typ\u00f3w atom\u00f3w\nall_atoms = []\nfor comp in compositions.dropna():\n    all_atoms.extend(comp.keys())\n\natom_types = Counter(all_atoms)\n\nprint(f\"\\n\ud83d\udcca Typy atom\u00f3w wyst\u0119puj\u0105ce w datasecie ({len(atom_types)}):\")\nfor atom, count in atom_types.most_common():\n    pct = (count / len(df_valid)) * 100\n    print(f\"  \u2022 {atom:3s}  wyst\u0119puje w {count:6,} cz\u0105steczkach ({pct:5.2f}%)\")\n\n# Rozk\u0142ad liczby atom\u00f3w per typ\natom_counts = {atom: [] for atom in atom_types.keys()}\nfor comp in compositions.dropna():\n    for atom in atom_types.keys():\n        atom_counts[atom].append(comp.get(atom, 0))\n\n# Konwersja do DataFrame\ndf_atoms = pd.DataFrame(atom_counts)\n\nprint(f\"\\n\ud83d\udcc8 Statystyki liczby atom\u00f3w:\")\nprint(df_atoms.describe())\n\n# ============================================================\n# 4. WIZUALIZACJA SK\u0141ADU ATOMOWEGO\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udcca WIZUALIZACJA SK\u0141ADU ATOMOWEGO\")\nprint(\"=\"*70)\n\n# Wykresy dla g\u0142\u00f3wnych atom\u00f3w (H, C, N, O, F)\nmain_atoms = ['H', 'C', 'N', 'O', 'F']\nmain_atoms = [atom for atom in main_atoms if atom in df_atoms.columns]\n\nfig, axes = plt.subplots(2, 3, figsize=(18, 10))\naxes = axes.flatten()\n\nfor i, atom in enumerate(main_atoms):\n    if atom in df_atoms.columns:\n        data = df_atoms[atom]\n        axes[i].hist(data, bins=50, color='steelblue', edgecolor='black', alpha=0.7)\n        axes[i].set_xlabel(f'Liczba atom\u00f3w {atom}', fontsize=11, fontweight='bold')\n        axes[i].set_ylabel('Liczba cz\u0105steczek', fontsize=11, fontweight='bold')\n        axes[i].set_title(f'Rozk\u0142ad atom\u00f3w {atom}\\n\u015arednia: {data.mean():.1f}, Max: {data.max():.0f}', \n                         fontsize=12, fontweight='bold')\n        axes[i].grid(axis='y', alpha=0.3)\n\n# Wykres por\u00f3wnawczy - \u015brednie liczby atom\u00f3w\nif len(main_atoms) &lt; 6:\n    ax_comparison = axes[5]\n    means = [df_atoms[atom].mean() for atom in main_atoms]\n    colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'][:len(main_atoms)]\n    bars = ax_comparison.bar(main_atoms, means, color=colors, edgecolor='black', linewidth=1.5)\n    ax_comparison.set_ylabel('\u015arednia liczba atom\u00f3w', fontsize=11, fontweight='bold')\n    ax_comparison.set_title('\u015aredni sk\u0142ad atomowy cz\u0105steczek QM9', fontsize=12, fontweight='bold')\n    ax_comparison.grid(axis='y', alpha=0.3)\n\n    for bar, val in zip(bars, means):\n        ax_comparison.text(bar.get_x() + bar.get_width()/2, val + 0.1, \n                          f'{val:.1f}', ha='center', fontweight='bold')\n\nplt.tight_layout()\nplt.savefig('qm9_atomic_composition.png', dpi=300, bbox_inches='tight')\nprint(\"\u2705 Zapisano: qm9_atomic_composition.png\")\nplt.show()\n\n# ============================================================\n# 5. ANALIZA W\u0141A\u015aCIWO\u015aCI MOLEKULARNYCH (RDKit)\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\u2697\ufe0f OBLICZANIE DESKRYPTOR\u00d3W MOLEKULARNYCH\")\nprint(\"=\"*70)\n\ndef calculate_rdkit_descriptors(smiles):\n    \"\"\"Oblicza podstawowe deskryptory RDKit\"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n\n    try:\n        return {\n            'MolWt': Descriptors.MolWt(mol),\n            'NumAtoms': mol.GetNumAtoms(),\n            'NumHeavyAtoms': mol.GetNumHeavyAtoms(),\n            'NumHeteroatoms': rdMolDescriptors.CalcNumHeteroatoms(mol),\n            'NumRotatableBonds': rdMolDescriptors.CalcNumRotatableBonds(mol),\n            'NumHBD': rdMolDescriptors.CalcNumHBD(mol),\n            'NumHBA': rdMolDescriptors.CalcNumHBA(mol),\n            'NumRings': rdMolDescriptors.CalcNumRings(mol),\n            'NumAromaticRings': rdMolDescriptors.CalcNumAromaticRings(mol),\n            'TPSA': Descriptors.TPSA(mol),\n            'LogP': Descriptors.MolLogP(mol),\n            'FractionCSP3': rdMolDescriptors.CalcFractionCsp3(mol)\n        }\n    except:\n        return None\n\nprint(\"Obliczam deskryptory RDKit dla poprawnych struktur...\")\ndescriptors = df_valid['SMILES'].apply(calculate_rdkit_descriptors)\ndf_descriptors = descriptors.apply(pd.Series)\n\n# Sprawdzenie czy s\u0105 jakiekolwiek dane\nif df_descriptors.empty or df_descriptors.shape[1] == 0:\n    print(\"\\n\u26a0\ufe0f  BRAK POPRAWNYCH STRUKTUR DO ANALIZY!\")\n    print(\"   Wszystkie SMILES s\u0105 niepoprawne lub nie mo\u017cna obliczy\u0107 deskryptor\u00f3w.\")\nelse:\n    # Dodanie do g\u0142\u00f3wnego DataFrame\n    df_valid = pd.concat([df_valid.reset_index(drop=True), \n                          df_descriptors.reset_index(drop=True)], axis=1)\n\n    print(f\"\u2705 Obliczono {len(df_descriptors.columns)} deskryptor\u00f3w dla {len(df_valid)} struktur\")\n\n    print(\"\\n\ud83d\udcca Statystyki deskryptor\u00f3w molekularnych:\")\n    print(df_descriptors.describe())\n\n# ============================================================\n# 6. CHARAKTERYSTYKA DATASETU QM9\n# ============================================================\n\nif not df_descriptors.empty and df_descriptors.shape[1] &gt; 0:\n    print(\"\\n\" + \"=\"*70)\n    print(\"\ud83d\udccb CHARAKTERYSTYKA DATASETU QM9\")\n    print(\"=\"*70)\n\n    print(f\"\"\"\n\ud83d\udd2c SK\u0141AD CHEMICZNY:\n  \u2022 Dozwolone atomy: {', '.join(sorted(atom_types.keys()))}\n  \u2022 Najcz\u0119stsze atomy: H, C, N, O, F (QM9 spec)\n  \u2022 \u015arednia liczba atom\u00f3w: {df_descriptors['NumAtoms'].mean():.1f}\n  \u2022 \u015arednia liczba ci\u0119\u017ckich atom\u00f3w: {df_descriptors['NumHeavyAtoms'].mean():.1f}\n  \u2022 Max ci\u0119\u017ckich atom\u00f3w: {df_descriptors['NumHeavyAtoms'].max():.0f} (limit QM9: 9)\n\n\ud83d\udccf ROZMIAR MOLEKU\u0141:\n  \u2022 Masa molowa: {df_descriptors['MolWt'].mean():.1f} \u00b1 {df_descriptors['MolWt'].std():.1f} g/mol\n  \u2022 Zakres: {df_descriptors['MolWt'].min():.1f} - {df_descriptors['MolWt'].max():.1f} g/mol\n\n\ud83d\udd17 STRUKTURY:\n  \u2022 \u015arednia liczba pier\u015bcieni: {df_descriptors['NumRings'].mean():.2f}\n  \u2022 Cz\u0105steczki aromatyczne: {(df_descriptors['NumAromaticRings'] &gt; 0).sum():,} ({(df_descriptors['NumAromaticRings'] &gt; 0).sum()/len(df_descriptors)*100:.1f}%)\n  \u2022 \u015arednia rotowalne wi\u0105zania: {df_descriptors['NumRotatableBonds'].mean():.2f}\n\n\ud83d\udca7 W\u0141A\u015aCIWO\u015aCI FIZYKOCHEMICZNE:\n  \u2022 \u015arednie LogP: {df_descriptors['LogP'].mean():.2f} \u00b1 {df_descriptors['LogP'].std():.2f}\n  \u2022 \u015arednie TPSA: {df_descriptors['TPSA'].mean():.1f} \u0172\n  \u2022 \u015arednia frakcja sp3: {df_descriptors['FractionCSP3'].mean():.2f}\n\n\u2705 JAKO\u015a\u0106 DANYCH:\n  \u2022 Validacja SMILES: {validity_pct:.2f}%\n  \u2022 Kompletno\u015b\u0107: {(df['is_valid'].sum() / len(df) * 100):.2f}%\n  \u2022 B\u0142\u0119dne struktury: {invalid_smiles:,}\n\"\"\")\n\n# ============================================================\n# 7. WIZUALIZACJA POR\u00d3WNAWCZA\n# ============================================================\n\nif not df_descriptors.empty and df_descriptors.shape[1] &gt; 0:\n    print(\"\\n\" + \"=\"*70)\n    print(\"\ud83d\udcca WIZUALIZACJA W\u0141A\u015aCIWO\u015aCI MOLEKULARNYCH\")\n    print(\"=\"*70)\n\n    fig, axes = plt.subplots(2, 3, figsize=(18, 10))\n\n    # 1. Masa molowa\n    axes[0, 0].hist(df_descriptors['MolWt'], bins=50, color='#3498db', \n                    edgecolor='black', alpha=0.7)\n    axes[0, 0].set_xlabel('Masa molowa (g/mol)', fontweight='bold')\n    axes[0, 0].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[0, 0].set_title('Rozk\u0142ad masy molowej', fontweight='bold', fontsize=12)\n    axes[0, 0].grid(axis='y', alpha=0.3)\n\n    # 2. Liczba ci\u0119\u017ckich atom\u00f3w\n    axes[0, 1].hist(df_descriptors['NumHeavyAtoms'], bins=range(1, 11), \n                    color='#e74c3c', edgecolor='black', alpha=0.7)\n    axes[0, 1].set_xlabel('Liczba ci\u0119\u017ckich atom\u00f3w', fontweight='bold')\n    axes[0, 1].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[0, 1].set_title('Rozk\u0142ad liczby ci\u0119\u017ckich atom\u00f3w (max=9)', fontweight='bold', fontsize=12)\n    axes[0, 1].grid(axis='y', alpha=0.3)\n\n    # 3. LogP\n    axes[0, 2].hist(df_descriptors['LogP'], bins=50, color='#2ecc71', \n                    edgecolor='black', alpha=0.7)\n    axes[0, 2].set_xlabel('LogP', fontweight='bold')\n    axes[0, 2].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[0, 2].set_title('Rozk\u0142ad lipofilowo\u015bci (LogP)', fontweight='bold', fontsize=12)\n    axes[0, 2].grid(axis='y', alpha=0.3)\n\n    # 4. TPSA\n    axes[1, 0].hist(df_descriptors['TPSA'], bins=50, color='#f39c12', \n                    edgecolor='black', alpha=0.7)\n    axes[1, 0].set_xlabel('TPSA (\u0172)', fontweight='bold')\n    axes[1, 0].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[1, 0].set_title('Rozk\u0142ad polarnej powierzchni (TPSA)', fontweight='bold', fontsize=12)\n    axes[1, 0].grid(axis='y', alpha=0.3)\n\n    # 5. Liczba pier\u015bcieni\n    ring_counts = df_descriptors['NumRings'].value_counts().sort_index()\n    axes[1, 1].bar(ring_counts.index, ring_counts.values, color='#9b59b6', \n                   edgecolor='black', alpha=0.7)\n    axes[1, 1].set_xlabel('Liczba pier\u015bcieni', fontweight='bold')\n    axes[1, 1].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[1, 1].set_title('Rozk\u0142ad liczby pier\u015bcieni', fontweight='bold', fontsize=12)\n    axes[1, 1].grid(axis='y', alpha=0.3)\n\n    # 6. Frakcja sp3\n    axes[1, 2].hist(df_descriptors['FractionCSP3'], bins=50, color='#1abc9c', \n                    edgecolor='black', alpha=0.7)\n    axes[1, 2].set_xlabel('Frakcja w\u0119gli sp\u00b3', fontweight='bold')\n    axes[1, 2].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[1, 2].set_title('Rozk\u0142ad frakcji sp\u00b3 (saturacja)', fontweight='bold', fontsize=12)\n    axes[1, 2].grid(axis='y', alpha=0.3)\n\n    plt.suptitle('W\u0142a\u015bciwo\u015bci molekularne datasetu QM9', fontsize=16, fontweight='bold', y=1.00)\n    plt.tight_layout()\n    plt.savefig('qm9_molecular_properties.png', dpi=300, bbox_inches='tight')\n    print(\"\u2705 Zapisano: qm9_molecular_properties.png\")\n    plt.show()\nelse:\n    print(\"\\n\u26a0\ufe0f  Brak danych do wizualizacji w\u0142a\u015bciwo\u015bci molekularnych\")\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\u2705 WALIDACJA I ANALIZA SMILES ZAKO\u0143CZONA!\")\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nWALIDACJA STRUKTUR SMILES - QM9 DATASET\n======================================================================\n\n\ud83d\udccb ETAP 1: PODSTAWOWA WALIDACJA\n----------------------------------------------------------------------\nWalidacja struktur SMILES...\nPrzyk\u0142adowe SMILES do walidacji:\n['[H]C([H])([H])C([H])([H])[N@@H+]1C([H])([H])[C@]1(C([H])([H])[H])C([H])([H])C([H])([H])C([H])([H])[H]', '[H]O[C@@]12C([H])([H])O[C@]1([H])[C@]2([H])[C@]([H])(O[H])C([H])([H])[H]', '[H]C1([H])C([H])([H])[C@]2([H])[C@@]1([H])[C@]1([H])OC([H])([H])[C@@]12C([H])([H])[H]', '[H]OC([H])([H])[C@]1(C([H])([H])C#N)OC1([H])[H]', '[H]N1[C@]2([H])C(=O)[C@@]1([H])C([H])([H])OC2([H])[H]']\n\n\u2705 Poprawne SMILES: 1,000 (100.00%)\n\u274c Niepoprawne SMILES: 0 (0.00%)\n\n\u2713 Przyk\u0142ady POPRAWNYCH SMILES:\n['[H]C([H])([H])C([H])([H])[N@@H+]1C([H])([H])[C@]1(C([H])([H])[H])C([H])([H])C([H])([H])C([H])([H])[H]', '[H]O[C@@]12C([H])([H])O[C@]1([H])[C@]2([H])[C@]([H])(O[H])C([H])([H])[H]', '[H]C1([H])C([H])([H])[C@]2([H])[C@@]1([H])[C@]1([H])OC([H])([H])[C@@]12C([H])([H])[H]']\n\n\u2705 WSZYSTKIE SMILES S\u0104 POPRAWNE! Dataset QM9 ma 100% validacj\u0119.\n\n======================================================================\n\ud83e\uddea ANALIZA SK\u0141ADU CHEMICZNEGO\n======================================================================\n\nAnalizuj\u0119 sk\u0142ad atomowy cz\u0105steczek...\n\n\ud83d\udcca Typy atom\u00f3w wyst\u0119puj\u0105ce w datasecie (5):\n  \u2022 C    wyst\u0119puje w  1,000 cz\u0105steczkach (100.00%)\n  \u2022 O    wyst\u0119puje w    843 cz\u0105steczkach (84.30%)\n  \u2022 N    wyst\u0119puje w    622 cz\u0105steczkach (62.20%)\n  \u2022 H    wyst\u0119puje w     16 cz\u0105steczkach ( 1.60%)\n  \u2022 F    wyst\u0119puje w     14 cz\u0105steczkach ( 1.40%)\n\n\ud83d\udcc8 Statystyki liczby atom\u00f3w:\n                 C            N            O            H            F\ncount  1000.000000  1000.000000  1000.000000  1000.000000  1000.000000\nmean      6.251000     1.093000     1.392000     0.017000     0.020000\nstd       1.282046     1.138265     0.875844     0.136857     0.188774\nmin       2.000000     0.000000     0.000000     0.000000     0.000000\n25%       5.000000     0.000000     1.000000     0.000000     0.000000\n50%       6.000000     1.000000     1.000000     0.000000     0.000000\n75%       7.000000     2.000000     2.000000     0.000000     0.000000\nmax       9.000000     6.000000     4.000000     2.000000     3.000000\n\n======================================================================\n\ud83d\udcca WIZUALIZACJA SK\u0141ADU ATOMOWEGO\n======================================================================\n\u2705 Zapisano: qm9_atomic_composition.png\n</pre> <pre>\n======================================================================\n\u2697\ufe0f OBLICZANIE DESKRYPTOR\u00d3W MOLEKULARNYCH\n======================================================================\nObliczam deskryptory RDKit dla poprawnych struktur...\n\n\u26a0\ufe0f  BRAK POPRAWNYCH STRUKTUR DO ANALIZY!\n   Wszystkie SMILES s\u0105 niepoprawne lub nie mo\u017cna obliczy\u0107 deskryptor\u00f3w.\n\n\u26a0\ufe0f  Brak danych do wizualizacji w\u0142a\u015bciwo\u015bci molekularnych\n\n======================================================================\n\u2705 WALIDACJA I ANALIZA SMILES ZAKO\u0143CZONA!\n======================================================================\n</pre> In\u00a0[17]: <pre># ============================================================\n# KOM\u00d3RKA 7: WALIDACJA I ANALIZA STRUKTUR SMILES\n# ============================================================\n\nfrom rdkit import Chem, RDLogger\nfrom rdkit.Chem import Descriptors, rdMolDescriptors\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom collections import Counter\n\n# Wyciszenie ostrze\u017ce\u0144 RDKit\nRDLogger.DisableLog('rdApp.*')\n\nprint(\"=\"*70)\nprint(\"WALIDACJA STRUKTUR SMILES - QM9 DATASET\")\nprint(\"=\"*70)\n\n# ============================================================\n# 1. PODSTAWOWA WALIDACJA SMILES\n# ============================================================\n\nprint(\"\\n\ud83d\udccb ETAP 1: PODSTAWOWA WALIDACJA\")\nprint(\"-\" * 70)\n\n# Usuni\u0119cie starych kolumn walidacji je\u015bli istniej\u0105\nif 'is_valid' in df.columns:\n    df = df.drop(columns=['is_valid'])\nif 'error_type' in df.columns:\n    df = df.drop(columns=['error_type'])\n\ndef validate_smiles_detailed(smiles):\n    \"\"\"Szczeg\u00f3\u0142owa walidacja SMILES z diagnoz\u0105 b\u0142\u0119d\u00f3w\"\"\"\n    try:\n        mol = Chem.MolFromSmiles(smiles)\n        if mol is None:\n            return {'valid': False, 'error': 'Parse Error', 'mol': None}\n\n        # Pr\u00f3ba sanityzacji\n        Chem.SanitizeMol(mol)\n        return {'valid': True, 'error': None, 'mol': mol}\n\n    except Exception as e:\n        error_type = str(e).split(':')[0] if ':' in str(e) else str(e)\n        return {'valid': False, 'error': error_type, 'mol': None}\n\n# Walidacja wszystkich SMILES\nprint(\"Walidacja struktur SMILES...\")\nvalidation_results = df['SMILES'].apply(validate_smiles_detailed)\n\ndf['is_valid'] = validation_results.apply(lambda x: x['valid'])\ndf['error_type'] = validation_results.apply(lambda x: x['error'])\n\n# Statystyki\ntotal_smiles = len(df)\nvalid_smiles = df['is_valid'].sum()\ninvalid_smiles = total_smiles - valid_smiles\nvalidity_pct = (valid_smiles / total_smiles) * 100\n\nprint(f\"\\n\u2705 Poprawne SMILES: {valid_smiles:,} ({validity_pct:.2f}%)\")\nprint(f\"\u274c Niepoprawne SMILES: {invalid_smiles:,} ({(100-validity_pct):.2f}%)\")\n\n# ============================================================\n# 2. SPRAWDZENIE CZY MAMY POPRAWNE DANE\n# ============================================================\n\nif valid_smiles == 0:\n    print(\"\\n\" + \"=\"*70)\n    print(\"\u274c B\u0141\u0104D: BRAK POPRAWNYCH STRUKTUR!\")\n    print(\"=\"*70)\n    print(\"\\nPrawdopodobne przyczyny:\")\n    print(\"  1. Kolumna 'is_valid' mia\u0142a ju\u017c warto\u015bci False z poprzedniego uruchomienia\")\n    print(\"  2. Problem z bibliotek\u0105 RDKit\")\n    print(\"\\nSpr\u00f3buj zrestartowa\u0107 kernel i uruchomi\u0107 ponownie od pocz\u0105tku.\")\nelse:\n    print(f\"\\n\u2713 Kontynuuj\u0119 analiz\u0119 {valid_smiles:,} poprawnych struktur...\")\n\n# Tylko dla poprawnych SMILES\ndf_valid = df[df['is_valid']].copy()\n\n# ============================================================\n# 3. ANALIZA SK\u0141ADU CHEMICZNEGO\n# ============================================================\n\nif len(df_valid) &gt; 0:\n    print(\"\\n\" + \"=\"*70)\n    print(\"\ud83e\uddea ANALIZA SK\u0141ADU CHEMICZNEGO\")\n    print(\"=\"*70)\n\n    def analyze_composition(smiles):\n        \"\"\"Analiza sk\u0142adu atomowego cz\u0105steczki\"\"\"\n        mol = Chem.MolFromSmiles(smiles)\n        if mol is None:\n            return None\n        atoms = [atom.GetSymbol() for atom in mol.GetAtoms()]\n        return Counter(atoms)\n\n    print(\"\\nAnalizuj\u0119 sk\u0142ad atomowy cz\u0105steczek...\")\n    compositions = df_valid['SMILES'].apply(analyze_composition)\n\n    # Ekstrakcja wszystkich typ\u00f3w atom\u00f3w\n    all_atoms = []\n    for comp in compositions.dropna():\n        all_atoms.extend(comp.keys())\n\n    atom_types = Counter(all_atoms)\n\n    print(f\"\\n\ud83d\udcca Typy atom\u00f3w wyst\u0119puj\u0105ce w datasecie ({len(atom_types)}):\")\n    for atom, count in atom_types.most_common():\n        pct = (count / len(df_valid)) * 100\n        print(f\"  \u2022 {atom:3s}  wyst\u0119puje w {count:6,} cz\u0105steczkach ({pct:5.2f}%)\")\n\n    # Rozk\u0142ad liczby atom\u00f3w per typ\n    atom_counts = {atom: [] for atom in atom_types.keys()}\n    for comp in compositions.dropna():\n        for atom in atom_types.keys():\n            atom_counts[atom].append(comp.get(atom, 0))\n\n    # Konwersja do DataFrame\n    df_atoms = pd.DataFrame(atom_counts)\n\n    print(f\"\\n\ud83d\udcc8 Statystyki liczby atom\u00f3w:\")\n    print(df_atoms.describe())\n\n    # ============================================================\n    # 4. WIZUALIZACJA SK\u0141ADU ATOMOWEGO\n    # ============================================================\n\n    print(\"\\n\" + \"=\"*70)\n    print(\"\ud83d\udcca WIZUALIZACJA SK\u0141ADU ATOMOWEGO\")\n    print(\"=\"*70)\n\n    # Wykresy dla g\u0142\u00f3wnych atom\u00f3w (H, C, N, O, F)\n    main_atoms = ['H', 'C', 'N', 'O', 'F']\n    main_atoms = [atom for atom in main_atoms if atom in df_atoms.columns]\n\n    fig, axes = plt.subplots(2, 3, figsize=(18, 10))\n    axes = axes.flatten()\n\n    for i, atom in enumerate(main_atoms):\n        if atom in df_atoms.columns:\n            data = df_atoms[atom]\n            axes[i].hist(data, bins=50, color='steelblue', edgecolor='black', alpha=0.7)\n            axes[i].set_xlabel(f'Liczba atom\u00f3w {atom}', fontsize=11, fontweight='bold')\n            axes[i].set_ylabel('Liczba cz\u0105steczek', fontsize=11, fontweight='bold')\n            axes[i].set_title(f'Rozk\u0142ad atom\u00f3w {atom}\\n\u015arednia: {data.mean():.1f}, Max: {data.max():.0f}', \n                             fontsize=12, fontweight='bold')\n            axes[i].grid(axis='y', alpha=0.3)\n\n    # Wykres por\u00f3wnawczy - \u015brednie liczby atom\u00f3w\n    if len(main_atoms) &lt; 6:\n        ax_comparison = axes[5]\n        means = [df_atoms[atom].mean() for atom in main_atoms]\n        colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'][:len(main_atoms)]\n        bars = ax_comparison.bar(main_atoms, means, color=colors, edgecolor='black', linewidth=1.5)\n        ax_comparison.set_ylabel('\u015arednia liczba atom\u00f3w', fontsize=11, fontweight='bold')\n        ax_comparison.set_title('\u015aredni sk\u0142ad atomowy cz\u0105steczek QM9', fontsize=12, fontweight='bold')\n        ax_comparison.grid(axis='y', alpha=0.3)\n\n        for bar, val in zip(bars, means):\n            ax_comparison.text(bar.get_x() + bar.get_width()/2, val + 0.1, \n                              f'{val:.1f}', ha='center', fontweight='bold')\n\n    plt.tight_layout()\n    plt.savefig('qm9_atomic_composition.png', dpi=300, bbox_inches='tight')\n    print(\"\u2705 Zapisano: qm9_atomic_composition.png\")\n    plt.show()\n\n    # ============================================================\n    # 5. ANALIZA W\u0141A\u015aCIWO\u015aCI MOLEKULARNYCH (RDKit)\n    # ============================================================\n\n    print(\"\\n\" + \"=\"*70)\n    print(\"\u2697\ufe0f OBLICZANIE DESKRYPTOR\u00d3W MOLEKULARNYCH\")\n    print(\"=\"*70)\n\n    def calculate_rdkit_descriptors(smiles):\n        \"\"\"Oblicza podstawowe deskryptory RDKit\"\"\"\n        mol = Chem.MolFromSmiles(smiles)\n        if mol is None:\n            return None\n\n        try:\n            return {\n                'MolWt': Descriptors.MolWt(mol),\n                'NumAtoms': mol.GetNumAtoms(),\n                'NumHeavyAtoms': mol.GetNumHeavyAtoms(),\n                'NumHeteroatoms': rdMolDescriptors.CalcNumHeteroatoms(mol),\n                'NumRotatableBonds': rdMolDescriptors.CalcNumRotatableBonds(mol),\n                'NumHBD': rdMolDescriptors.CalcNumHBD(mol),\n                'NumHBA': rdMolDescriptors.CalcNumHBA(mol),\n                'NumRings': rdMolDescriptors.CalcNumRings(mol),\n                'NumAromaticRings': rdMolDescriptors.CalcNumAromaticRings(mol),\n                'TPSA': Descriptors.TPSA(mol),\n                'LogP': Descriptors.MolLogP(mol),\n                'FractionCSP3': rdMolDescriptors.CalcFractionCsp3(mol)\n            }\n        except:\n            return None\n\n    print(\"Obliczam deskryptory RDKit dla poprawnych struktur...\")\n    descriptors = df_valid['SMILES'].apply(calculate_rdkit_descriptors)\n    df_descriptors = descriptors.apply(pd.Series)\n\n    # Dodanie do g\u0142\u00f3wnego DataFrame\n    df_valid = pd.concat([df_valid.reset_index(drop=True), \n                          df_descriptors.reset_index(drop=True)], axis=1)\n\n    print(f\"\u2705 Obliczono {len(df_descriptors.columns)} deskryptor\u00f3w dla {len(df_valid)} struktur\")\n\n    print(\"\\n\ud83d\udcca Statystyki deskryptor\u00f3w molekularnych:\")\n    print(df_descriptors.describe())\n\n    # ============================================================\n    # 6. WIZUALIZACJA W\u0141A\u015aCIWO\u015aCI MOLEKULARNYCH\n    # ============================================================\n\n    print(\"\\n\" + \"=\"*70)\n    print(\"\ud83d\udcca WIZUALIZACJA W\u0141A\u015aCIWO\u015aCI MOLEKULARNYCH\")\n    print(\"=\"*70)\n\n    fig, axes = plt.subplots(2, 3, figsize=(18, 10))\n\n    # 1. Masa molowa\n    axes[0, 0].hist(df_descriptors['MolWt'], bins=50, color='#3498db', \n                    edgecolor='black', alpha=0.7)\n    axes[0, 0].set_xlabel('Masa molowa (g/mol)', fontweight='bold')\n    axes[0, 0].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[0, 0].set_title('Rozk\u0142ad masy molowej', fontweight='bold', fontsize=12)\n    axes[0, 0].grid(axis='y', alpha=0.3)\n\n    # 2. Liczba ci\u0119\u017ckich atom\u00f3w\n    axes[0, 1].hist(df_descriptors['NumHeavyAtoms'], bins=range(1, 11), \n                    color='#e74c3c', edgecolor='black', alpha=0.7)\n    axes[0, 1].set_xlabel('Liczba ci\u0119\u017ckich atom\u00f3w', fontweight='bold')\n    axes[0, 1].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[0, 1].set_title('Rozk\u0142ad liczby ci\u0119\u017ckich atom\u00f3w (max=9)', fontweight='bold', fontsize=12)\n    axes[0, 1].grid(axis='y', alpha=0.3)\n\n    # 3. LogP\n    axes[0, 2].hist(df_descriptors['LogP'], bins=50, color='#2ecc71', \n                    edgecolor='black', alpha=0.7)\n    axes[0, 2].set_xlabel('LogP', fontweight='bold')\n    axes[0, 2].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[0, 2].set_title('Rozk\u0142ad lipofilowo\u015bci (LogP)', fontweight='bold', fontsize=12)\n    axes[0, 2].grid(axis='y', alpha=0.3)\n\n    # 4. TPSA\n    axes[1, 0].hist(df_descriptors['TPSA'], bins=50, color='#f39c12', \n                    edgecolor='black', alpha=0.7)\n    axes[1, 0].set_xlabel('TPSA (\u0172)', fontweight='bold')\n    axes[1, 0].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[1, 0].set_title('Rozk\u0142ad polarnej powierzchni (TPSA)', fontweight='bold', fontsize=12)\n    axes[1, 0].grid(axis='y', alpha=0.3)\n\n    # 5. Liczba pier\u015bcieni\n    ring_counts = df_descriptors['NumRings'].value_counts().sort_index()\n    axes[1, 1].bar(ring_counts.index, ring_counts.values, color='#9b59b6', \n                   edgecolor='black', alpha=0.7)\n    axes[1, 1].set_xlabel('Liczba pier\u015bcieni', fontweight='bold')\n    axes[1, 1].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[1, 1].set_title('Rozk\u0142ad liczby pier\u015bcieni', fontweight='bold', fontsize=12)\n    axes[1, 1].grid(axis='y', alpha=0.3)\n\n    # 6. Frakcja sp3\n    axes[1, 2].hist(df_descriptors['FractionCSP3'], bins=50, color='#1abc9c', \n                    edgecolor='black', alpha=0.7)\n    axes[1, 2].set_xlabel('Frakcja w\u0119gli sp\u00b3', fontweight='bold')\n    axes[1, 2].set_ylabel('Liczba cz\u0105steczek', fontweight='bold')\n    axes[1, 2].set_title('Rozk\u0142ad frakcji sp\u00b3 (saturacja)', fontweight='bold', fontsize=12)\n    axes[1, 2].grid(axis='y', alpha=0.3)\n\n    plt.suptitle('W\u0142a\u015bciwo\u015bci molekularne datasetu QM9', fontsize=16, fontweight='bold', y=1.00)\n    plt.tight_layout()\n    plt.savefig('qm9_molecular_properties.png', dpi=300, bbox_inches='tight')\n    print(\"\u2705 Zapisano: qm9_molecular_properties.png\")\n    plt.show()\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\u2705 WALIDACJA I ANALIZA SMILES ZAKO\u0143CZONA!\")\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nWALIDACJA STRUKTUR SMILES - QM9 DATASET\n======================================================================\n\n\ud83d\udccb ETAP 1: PODSTAWOWA WALIDACJA\n----------------------------------------------------------------------\nWalidacja struktur SMILES...\n\n\u2705 Poprawne SMILES: 1,000 (100.00%)\n\u274c Niepoprawne SMILES: 0 (0.00%)\n\n\u2713 Kontynuuj\u0119 analiz\u0119 1,000 poprawnych struktur...\n\n======================================================================\n\ud83e\uddea ANALIZA SK\u0141ADU CHEMICZNEGO\n======================================================================\n\nAnalizuj\u0119 sk\u0142ad atomowy cz\u0105steczek...\n\n\ud83d\udcca Typy atom\u00f3w wyst\u0119puj\u0105ce w datasecie (5):\n  \u2022 C    wyst\u0119puje w  1,000 cz\u0105steczkach (100.00%)\n  \u2022 O    wyst\u0119puje w    843 cz\u0105steczkach (84.30%)\n  \u2022 N    wyst\u0119puje w    622 cz\u0105steczkach (62.20%)\n  \u2022 H    wyst\u0119puje w     16 cz\u0105steczkach ( 1.60%)\n  \u2022 F    wyst\u0119puje w     14 cz\u0105steczkach ( 1.40%)\n\n\ud83d\udcc8 Statystyki liczby atom\u00f3w:\n                 C            N            O            H            F\ncount  1000.000000  1000.000000  1000.000000  1000.000000  1000.000000\nmean      6.251000     1.093000     1.392000     0.017000     0.020000\nstd       1.282046     1.138265     0.875844     0.136857     0.188774\nmin       2.000000     0.000000     0.000000     0.000000     0.000000\n25%       5.000000     0.000000     1.000000     0.000000     0.000000\n50%       6.000000     1.000000     1.000000     0.000000     0.000000\n75%       7.000000     2.000000     2.000000     0.000000     0.000000\nmax       9.000000     6.000000     4.000000     2.000000     3.000000\n\n======================================================================\n\ud83d\udcca WIZUALIZACJA SK\u0141ADU ATOMOWEGO\n======================================================================\n\u2705 Zapisano: qm9_atomic_composition.png\n</pre> <pre>\n======================================================================\n\u2697\ufe0f OBLICZANIE DESKRYPTOR\u00d3W MOLEKULARNYCH\n======================================================================\nObliczam deskryptory RDKit dla poprawnych struktur...\n\u2705 Obliczono 0 deskryptor\u00f3w dla 1000 struktur\n\n\ud83d\udcca Statystyki deskryptor\u00f3w molekularnych:\n</pre> <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[17], line 213\n    210 print(f\"\u2705 Obliczono {len(df_descriptors.columns)} deskryptor\u00f3w dla {len(df_valid)} struktur\")\n    212 print(\"\\n\ud83d\udcca Statystyki deskryptor\u00f3w molekularnych:\")\n--&gt; 213 print(df_descriptors.describe())\n    215 # ============================================================\n    216 # 6. WIZUALIZACJA W\u0141A\u015aCIWO\u015aCI MOLEKULARNYCH\n    217 # ============================================================\n    219 print(\"\\n\" + \"=\"*70)\n\nFile c:\\Users\\slast\\miniconda3\\envs\\chem_eda\\lib\\site-packages\\pandas\\core\\generic.py:12041, in NDFrame.describe(self, percentiles, include, exclude)\n  11799 @final\n  11800 def describe(\n  11801     self,\n   (...)\n  11804     exclude=None,\n  11805 ) -&gt; Self:\n  11806     \"\"\"\n  11807     Generate descriptive statistics.\n  11808 \n   (...)\n  12039     max            NaN      3.0\n  12040     \"\"\"\n&gt; 12041     return describe_ndframe(\n  12042         obj=self,\n  12043         include=include,\n  12044         exclude=exclude,\n  12045         percentiles=percentiles,\n  12046     ).__finalize__(self, method=\"describe\")\n\nFile c:\\Users\\slast\\miniconda3\\envs\\chem_eda\\lib\\site-packages\\pandas\\core\\methods\\describe.py:91, in describe_ndframe(obj, include, exclude, percentiles)\n     87     describer = SeriesDescriber(\n     88         obj=cast(\"Series\", obj),\n     89     )\n     90 else:\n---&gt; 91     describer = DataFrameDescriber(\n     92         obj=cast(\"DataFrame\", obj),\n     93         include=include,\n     94         exclude=exclude,\n     95     )\n     97 result = describer.describe(percentiles=percentiles)\n     98 return cast(NDFrameT, result)\n\nFile c:\\Users\\slast\\miniconda3\\envs\\chem_eda\\lib\\site-packages\\pandas\\core\\methods\\describe.py:162, in DataFrameDescriber.__init__(self, obj, include, exclude)\n    159 self.exclude = exclude\n    161 if obj.ndim == 2 and obj.columns.size == 0:\n--&gt; 162     raise ValueError(\"Cannot describe a DataFrame without columns\")\n    164 super().__init__(obj)\n\nValueError: Cannot describe a DataFrame without columns</pre> In\u00a0[19]: <pre># ============================================================\n# KOM\u00d3RKA 8: ANALIZA PODZIA\u0141U TRAIN/VALID/TEST\n# ============================================================\n\nprint(\"=\"*70)\nprint(\"ANALIZA PODZIA\u0141U DATASETU - TRAIN/VALID/TEST\")\nprint(\"=\"*70)\n\n# ============================================================\n# 1. PODSTAWOWE STATYSTYKI PODZIA\u0141U\n# ============================================================\n\nprint(\"\\n\ud83d\udcca ETAP 1: ROZK\u0141AD DANYCH WED\u0141UG ZBIOR\u00d3W\")\nprint(\"-\" * 70)\n\n# Liczebno\u015b\u0107 poszczeg\u00f3lnych zbior\u00f3w\nsplit_counts = df['dataset_split'].value_counts().sort_index()\ntotal_samples = len(df)\n\nprint(\"\\n\ud83d\udcc8 Liczebno\u015b\u0107 zbior\u00f3w:\")\nfor split, count in split_counts.items():\n    pct = (count / total_samples) * 100\n    print(f\"  \u2022 {split:6s}: {count:7,} pr\u00f3bek ({pct:5.2f}%)\")\n\nprint(f\"\\n  RAZEM:    {total_samples:7,} pr\u00f3bek (100.00%)\")\n\n# ============================================================\n# 2. WIZUALIZACJA PODZIA\u0141U\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udcca WIZUALIZACJA PODZIA\u0141U\")\nprint(\"=\"*70)\n\nfig, axes = plt.subplots(1, 3, figsize=(18, 5))\n\n# 1. Wykres ko\u0142owy\ncolors = ['#3498db', '#2ecc71', '#e74c3c']\nwedges, texts, autotexts = axes[0].pie(split_counts.values, \n                                         labels=split_counts.index,\n                                         autopct='%1.1f%%',\n                                         colors=colors,\n                                         startangle=90,\n                                         textprops={'fontsize': 12, 'fontweight': 'bold'})\naxes[0].set_title('Rozk\u0142ad procentowy zbior\u00f3w', fontsize=14, fontweight='bold')\n\n# 2. Wykres s\u0142upkowy\nbars = axes[1].bar(split_counts.index, split_counts.values, \n                    color=colors, edgecolor='black', linewidth=1.5, alpha=0.8)\naxes[1].set_ylabel('Liczba pr\u00f3bek', fontsize=12, fontweight='bold')\naxes[1].set_xlabel('Zbi\u00f3r', fontsize=12, fontweight='bold')\naxes[1].set_title('Liczebno\u015b\u0107 zbior\u00f3w', fontsize=14, fontweight='bold')\naxes[1].grid(axis='y', alpha=0.3)\n\n# Dodanie warto\u015bci na s\u0142upkach\nfor bar, val in zip(bars, split_counts.values):\n    height = bar.get_height()\n    axes[1].text(bar.get_x() + bar.get_width()/2., height,\n                f'{val:,}', ha='center', va='bottom', fontweight='bold', fontsize=11)\n\n# 3. Proporcje wzgl\u0119dem ca\u0142o\u015bci\nproportions = (split_counts / total_samples * 100).values\naxes[2].barh(split_counts.index, proportions, color=colors, \n             edgecolor='black', linewidth=1.5, alpha=0.8)\naxes[2].set_xlabel('Procent ca\u0142ego datasetu (%)', fontsize=12, fontweight='bold')\naxes[2].set_title('Proporcje zbior\u00f3w', fontsize=14, fontweight='bold')\naxes[2].grid(axis='x', alpha=0.3)\n\n# Dodanie warto\u015bci\nfor i, (split, val) in enumerate(zip(split_counts.index, proportions)):\n    axes[2].text(val + 0.5, i, f'{val:.1f}%', \n                va='center', fontweight='bold', fontsize=11)\n\nplt.tight_layout()\nplt.savefig('qm9_dataset_split.png', dpi=300, bbox_inches='tight')\nprint(\"\u2705 Zapisano: qm9_dataset_split.png\")\nplt.show()\n\n# ============================================================\n# 3. ANALIZA BALANSU W\u0141A\u015aCIWO\u015aCI MI\u0118DZY ZBIORAMI\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udd2c ANALIZA BALANSU W\u0141A\u015aCIWO\u015aCI KWANTOWYCH\")\nprint(\"=\"*70)\n\n# Wyb\u00f3r kluczowych w\u0142a\u015bciwo\u015bci do analizy\nkey_properties = ['HOMO', 'LUMO', 'gap', 'dipole_moment', 'polarizability', \n                  'U0', 'H', 'G']\n\nprint(\"\\n\ud83d\udcca Por\u00f3wnanie \u015brednich warto\u015bci w\u0142a\u015bciwo\u015bci mi\u0119dzy zbiorami:\")\nprint(\"-\" * 70)\n\n# Tabela por\u00f3wnawcza\ncomparison_data = []\nfor prop in key_properties:\n    if prop in df.columns:\n        train_mean = df[df['dataset_split'] == 'train'][prop].mean()\n        valid_mean = df[df['dataset_split'] == 'valid'][prop].mean()\n        test_mean = df[df['dataset_split'] == 'test'][prop].mean()\n\n        # Obliczenie r\u00f3\u017cnic procentowych\n        max_diff = max(abs(train_mean - valid_mean), \n                       abs(train_mean - test_mean),\n                       abs(valid_mean - test_mean))\n        avg_mean = (train_mean + valid_mean + test_mean) / 3\n        diff_pct = (max_diff / abs(avg_mean) * 100) if avg_mean != 0 else 0\n\n        comparison_data.append({\n            'W\u0142a\u015bciwo\u015b\u0107': prop,\n            'Train': train_mean,\n            'Valid': valid_mean,\n            'Test': test_mean,\n            'Max Diff %': diff_pct\n        })\n\n        print(f\"\\n{prop:25s}\")\n        print(f\"  Train: {train_mean:10.4f}  |  Valid: {valid_mean:10.4f}  |  Test: {test_mean:10.4f}\")\n        print(f\"  Max r\u00f3\u017cnica: {diff_pct:.2f}%\")\n\ndf_comparison = pd.DataFrame(comparison_data)\n\n# Ocena balansu\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udccb OCENA BALANSU ZBIOR\u00d3W\")\nprint(\"=\"*70)\n\nmax_imbalance = df_comparison['Max Diff %'].max()\n\nprint(f\"\\n\u2713 Maksymalna r\u00f3\u017cnica mi\u0119dzy zbiorami: {max_imbalance:.2f}%\")\n\nif max_imbalance &lt; 1:\n    balance_status = \"\ud83d\udfe2 DOSKONA\u0141Y BALANS\"\n    balance_desc = \"Zbiory s\u0105 bardzo dobrze zbalansowane\"\nelif max_imbalance &lt; 3:\n    balance_status = \"\ud83d\udfe2 DOBRY BALANS\"\n    balance_desc = \"Zbiory s\u0105 dobrze zbalansowane\"\nelif max_imbalance &lt; 5:\n    balance_status = \"\ud83d\udfe1 AKCEPTOWALNY BALANS\"\n    balance_desc = \"Niewielkie r\u00f3\u017cnice mi\u0119dzy zbiorami\"\nelse:\n    balance_status = \"\ud83d\udd34 S\u0141ABY BALANS\"\n    balance_desc = \"Znacz\u0105ce r\u00f3\u017cnice mi\u0119dzy zbiorami\"\n\nprint(f\"\\n{balance_status}\")\nprint(f\"  {balance_desc}\")\n\n# ============================================================\n# 4. WIZUALIZACJA ROZK\u0141AD\u00d3W W\u0141A\u015aCIWO\u015aCI\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udcca WIZUALIZACJA ROZK\u0141AD\u00d3W KLUCZOWYCH W\u0141A\u015aCIWO\u015aCI\")\nprint(\"=\"*70)\n\n# Wyb\u00f3r 6 najwa\u017cniejszych w\u0142a\u015bciwo\u015bci\nplot_properties = ['HOMO', 'LUMO', 'gap', 'dipole_moment', 'U0', 'H']\n\nfig, axes = plt.subplots(2, 3, figsize=(18, 10))\naxes = axes.flatten()\n\nfor i, prop in enumerate(plot_properties):\n    if prop in df.columns:\n        # Rozk\u0142ady dla ka\u017cdego zbioru\n        for split, color in zip(['train', 'valid', 'test'], colors):\n            data = df[df['dataset_split'] == split][prop].dropna()\n            axes[i].hist(data, bins=50, alpha=0.5, label=split, \n                        color=color, edgecolor='black', linewidth=0.5)\n\n        axes[i].set_xlabel(prop, fontsize=11, fontweight='bold')\n        axes[i].set_ylabel('Liczba pr\u00f3bek', fontsize=11, fontweight='bold')\n        axes[i].set_title(f'Rozk\u0142ad {prop} w zbiorach', fontsize=12, fontweight='bold')\n        axes[i].legend()\n        axes[i].grid(axis='y', alpha=0.3)\n\nplt.suptitle('Por\u00f3wnanie rozk\u0142ad\u00f3w w\u0142a\u015bciwo\u015bci mi\u0119dzy zbiorami', \n             fontsize=16, fontweight='bold', y=1.00)\nplt.tight_layout()\nplt.savefig('qm9_split_distributions.png', dpi=300, bbox_inches='tight')\nprint(\"\u2705 Zapisano: qm9_split_distributions.png\")\nplt.show()\n\n# ============================================================\n# 5. BOXPLOTY - POR\u00d3WNANIE ZBIOR\u00d3W\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udce6 BOXPLOTY - POR\u00d3WNANIE MEDIANOWE\")\nprint(\"=\"*70)\n\nfig, axes = plt.subplots(2, 3, figsize=(18, 10))\naxes = axes.flatten()\n\nfor i, prop in enumerate(plot_properties):\n    if prop in df.columns:\n        # Przygotowanie danych\n        data_to_plot = [df[df['dataset_split'] == split][prop].dropna() \n                        for split in ['train', 'valid', 'test']]\n\n        bp = axes[i].boxplot(data_to_plot, \n                             labels=['Train', 'Valid', 'Test'],\n                             patch_artist=True,\n                             widths=0.6)\n\n        # Kolorowanie box\u00f3w\n        for patch, color in zip(bp['boxes'], colors):\n            patch.set_facecolor(color)\n            patch.set_alpha(0.7)\n\n        axes[i].set_ylabel(prop, fontsize=11, fontweight='bold')\n        axes[i].set_title(f'Boxplot {prop}', fontsize=12, fontweight='bold')\n        axes[i].grid(axis='y', alpha=0.3)\n\nplt.suptitle('Boxploty w\u0142a\u015bciwo\u015bci - por\u00f3wnanie zbior\u00f3w', \n             fontsize=16, fontweight='bold', y=1.00)\nplt.tight_layout()\nplt.savefig('qm9_split_boxplots.png', dpi=300, bbox_inches='tight')\nprint(\"\u2705 Zapisano: qm9_split_boxplots.png\")\nplt.show()\n\n# ============================================================\n# 6. POR\u00d3WNANIE ODCHYLE\u0143 STANDARDOWYCH\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udcca POR\u00d3WNANIE STATYSTYK OPISOWYCH\")\nprint(\"=\"*70)\n\nprint(\"\\nOdchylenia standardowe (im bardziej podobne, tym lepszy balans):\")\nprint(\"-\" * 70)\n\nfor prop in key_properties:\n    if prop in df.columns:\n        train_std = df[df['dataset_split'] == 'train'][prop].std()\n        valid_std = df[df['dataset_split'] == 'valid'][prop].std()\n        test_std = df[df['dataset_split'] == 'test'][prop].std()\n\n        # Obliczenie r\u00f3\u017cnicy\n        max_std = max(train_std, valid_std, test_std)\n        min_std = min(train_std, valid_std, test_std)\n        diff_pct = ((max_std - min_std) / max_std * 100) if max_std &gt; 0 else 0\n\n        print(f\"\\n{prop:20s}\")\n        print(f\"  Train: {train_std:10.4f}  |  Valid: {valid_std:10.4f}  |  Test: {test_std:10.4f}\")\n        print(f\"  R\u00f3\u017cnica: {diff_pct:.2f}%\")\n\n# ============================================================\n# 7. PODSUMOWANIE\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udccb PODSUMOWANIE ANALIZY PODZIA\u0141U\")\nprint(\"=\"*70)\n\nsimilar_count = (df_comparison['Max Diff %'] &lt; 3).sum()\ntotal_props = len(df_comparison)\n\nprint(f\"\"\"\n\ud83d\udcca ROZK\u0141AD LICZBOWY:\n  \u2022 Train: {split_counts['train']:,} ({split_counts['train']/total_samples*100:.1f}%)\n  \u2022 Valid: {split_counts['valid']:,} ({split_counts['valid']/total_samples*100:.1f}%)\n  \u2022 Test:  {split_counts['test']:,} ({split_counts['test']/total_samples*100:.1f}%)\n\n\u2696\ufe0f  BALANS W\u0141A\u015aCIWO\u015aCI:\n  \u2022 Status: {balance_status}\n  \u2022 Maksymalna r\u00f3\u017cnica \u015brednich: {max_imbalance:.2f}%\n  \u2022 W\u0142a\u015bciwo\u015bci z dobrym balansem: {similar_count}/{total_props}\n\n\u2705 WNIOSKI:\n  \u2022 {'Podzia\u0142 jest dobrze zbalansowany pod wzgl\u0119dem liczebno\u015bci' if max(split_counts.values)/min(split_counts.values) &lt; 1.2 else 'Podzia\u0142 ma lekk\u0105 nier\u00f3wno\u015b\u0107 liczebno\u015bci'}\n  \u2022 {'Rozk\u0142ady w\u0142a\u015bciwo\u015bci s\u0105 sp\u00f3jne mi\u0119dzy zbiorami' if max_imbalance &lt; 3 else 'Niekt\u00f3re w\u0142a\u015bciwo\u015bci mog\u0105 r\u00f3\u017cni\u0107 si\u0119 mi\u0119dzy zbiorami'}\n  \u2022 {'Dataset jest gotowy do trenowania modeli ML' if max_imbalance &lt; 5 else 'Rozwa\u017c dodatkowe sprawdzenie podzia\u0142u'}\n\n\ud83d\udca1 REKOMENDACJE:\n  \u2022 {'Brak konieczno\u015bci re-splittingu' if max_imbalance &lt; 3 else 'Rozwa\u017c stratified split dla krytycznych w\u0142a\u015bciwo\u015bci'}\n  \u2022 {'Mo\u017cesz bezpiecznie trenowa\u0107 modele na tym podziale' if similar_count/total_props &gt; 0.7 else 'Monitoruj metryki na wszystkich zbiorach podczas treningu'}\n\"\"\")\n\nprint(\"=\"*70)\nprint(\"\u2705 ANALIZA PODZIA\u0141U ZAKO\u0143CZONA!\")\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nANALIZA PODZIA\u0141U DATASETU - TRAIN/VALID/TEST\n======================================================================\n\n\ud83d\udcca ETAP 1: ROZK\u0141AD DANYCH WED\u0141UG ZBIOR\u00d3W\n----------------------------------------------------------------------\n\n\ud83d\udcc8 Liczebno\u015b\u0107 zbior\u00f3w:\n  \u2022 test  :      91 pr\u00f3bek ( 9.10%)\n  \u2022 train :     813 pr\u00f3bek (81.30%)\n  \u2022 valid :      96 pr\u00f3bek ( 9.60%)\n\n  RAZEM:      1,000 pr\u00f3bek (100.00%)\n\n======================================================================\n\ud83d\udcca WIZUALIZACJA PODZIA\u0141U\n======================================================================\n\u2705 Zapisano: qm9_dataset_split.png\n</pre> <pre>\n======================================================================\n\ud83d\udd2c ANALIZA BALANSU W\u0141A\u015aCIWO\u015aCI KWANTOWYCH\n======================================================================\n\n\ud83d\udcca Por\u00f3wnanie \u015brednich warto\u015bci w\u0142a\u015bciwo\u015bci mi\u0119dzy zbiorami:\n----------------------------------------------------------------------\n\nHOMO                     \n  Train:    -0.0224  |  Valid:    -0.0890  |  Test:    -0.0519\n  Max r\u00f3\u017cnica: 122.23%\n\nLUMO                     \n  Train:     0.0727  |  Valid:    -0.1290  |  Test:    -0.1003\n  Max r\u00f3\u017cnica: 386.37%\n\ngap                      \n  Train:     0.0839  |  Valid:    -0.0843  |  Test:    -0.0742\n  Max r\u00f3\u017cnica: 676.65%\n\ndipole_moment            \n  Train:    -0.0299  |  Valid:    -0.0693  |  Test:    -0.0120\n  Max r\u00f3\u017cnica: 154.55%\n\npolarizability           \n  Train:    -0.0297  |  Valid:    -0.0061  |  Test:    -0.0796\n  Max r\u00f3\u017cnica: 191.28%\n\nU0                       \n  Train:    -0.0125  |  Valid:    -0.0063  |  Test:    -0.0707\n  Max r\u00f3\u017cnica: 215.82%\n\nH                        \n  Train:     0.0289  |  Valid:     0.1364  |  Test:    -0.0878\n  Max r\u00f3\u017cnica: 867.44%\n\nG                        \n  Train:     0.0289  |  Valid:     0.1364  |  Test:    -0.0878\n  Max r\u00f3\u017cnica: 867.44%\n\n======================================================================\n\ud83d\udccb OCENA BALANSU ZBIOR\u00d3W\n======================================================================\n\n\u2713 Maksymalna r\u00f3\u017cnica mi\u0119dzy zbiorami: 867.44%\n\n\ud83d\udd34 S\u0141ABY BALANS\n  Znacz\u0105ce r\u00f3\u017cnice mi\u0119dzy zbiorami\n\n======================================================================\n\ud83d\udcca WIZUALIZACJA ROZK\u0141AD\u00d3W KLUCZOWYCH W\u0141A\u015aCIWO\u015aCI\n======================================================================\n\u2705 Zapisano: qm9_split_distributions.png\n</pre> <pre>\n======================================================================\n\ud83d\udce6 BOXPLOTY - POR\u00d3WNANIE MEDIANOWE\n======================================================================\n</pre> <pre>C:\\Users\\slast\\AppData\\Local\\Temp\\ipykernel_6436\\2569215989.py:200: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  bp = axes[i].boxplot(data_to_plot,\nC:\\Users\\slast\\AppData\\Local\\Temp\\ipykernel_6436\\2569215989.py:200: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  bp = axes[i].boxplot(data_to_plot,\nC:\\Users\\slast\\AppData\\Local\\Temp\\ipykernel_6436\\2569215989.py:200: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  bp = axes[i].boxplot(data_to_plot,\nC:\\Users\\slast\\AppData\\Local\\Temp\\ipykernel_6436\\2569215989.py:200: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  bp = axes[i].boxplot(data_to_plot,\nC:\\Users\\slast\\AppData\\Local\\Temp\\ipykernel_6436\\2569215989.py:200: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  bp = axes[i].boxplot(data_to_plot,\nC:\\Users\\slast\\AppData\\Local\\Temp\\ipykernel_6436\\2569215989.py:200: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  bp = axes[i].boxplot(data_to_plot,\n</pre> <pre>\u2705 Zapisano: qm9_split_boxplots.png\n</pre> <pre>\n======================================================================\n\ud83d\udcca POR\u00d3WNANIE STATYSTYK OPISOWYCH\n======================================================================\n\nOdchylenia standardowe (im bardziej podobne, tym lepszy balans):\n----------------------------------------------------------------------\n\nHOMO                \n  Train:     1.0495  |  Valid:     0.9226  |  Test:     0.9963\n  R\u00f3\u017cnica: 12.09%\n\nLUMO                \n  Train:     0.9760  |  Valid:     1.0129  |  Test:     1.1192\n  R\u00f3\u017cnica: 12.80%\n\ngap                 \n  Train:     1.0070  |  Valid:     0.9814  |  Test:     1.0664\n  R\u00f3\u017cnica: 7.97%\n\ndipole_moment       \n  Train:     1.0284  |  Valid:     0.9200  |  Test:     0.9418\n  R\u00f3\u017cnica: 10.55%\n\npolarizability      \n  Train:     1.0579  |  Valid:     1.1738  |  Test:     1.0389\n  R\u00f3\u017cnica: 11.50%\n\nU0                  \n  Train:     1.0377  |  Valid:     1.1266  |  Test:     1.0621\n  R\u00f3\u017cnica: 7.89%\n\nH                   \n  Train:     1.0520  |  Valid:     1.1977  |  Test:     1.0812\n  R\u00f3\u017cnica: 12.17%\n\nG                   \n  Train:     1.0520  |  Valid:     1.1977  |  Test:     1.0812\n  R\u00f3\u017cnica: 12.17%\n\n======================================================================\n\ud83d\udccb PODSUMOWANIE ANALIZY PODZIA\u0141U\n======================================================================\n\n\ud83d\udcca ROZK\u0141AD LICZBOWY:\n  \u2022 Train: 813 (81.3%)\n  \u2022 Valid: 96 (9.6%)\n  \u2022 Test:  91 (9.1%)\n\n\u2696\ufe0f  BALANS W\u0141A\u015aCIWO\u015aCI:\n  \u2022 Status: \ud83d\udd34 S\u0141ABY BALANS\n  \u2022 Maksymalna r\u00f3\u017cnica \u015brednich: 867.44%\n  \u2022 W\u0142a\u015bciwo\u015bci z dobrym balansem: 0/8\n\n\u2705 WNIOSKI:\n  \u2022 Podzia\u0142 ma lekk\u0105 nier\u00f3wno\u015b\u0107 liczebno\u015bci\n  \u2022 Niekt\u00f3re w\u0142a\u015bciwo\u015bci mog\u0105 r\u00f3\u017cni\u0107 si\u0119 mi\u0119dzy zbiorami\n  \u2022 Rozwa\u017c dodatkowe sprawdzenie podzia\u0142u\n\n\ud83d\udca1 REKOMENDACJE:\n  \u2022 Rozwa\u017c stratified split dla krytycznych w\u0142a\u015bciwo\u015bci\n  \u2022 Monitoruj metryki na wszystkich zbiorach podczas treningu\n\n======================================================================\n\u2705 ANALIZA PODZIA\u0141U ZAKO\u0143CZONA!\n======================================================================\n</pre> In\u00a0[20]: <pre># ============================================================\n# KOM\u00d3RKA 9: ANALIZA SK\u0141ADU CHEMICZNEGO\n# ============================================================\n\nprint(\"=\"*70)\nprint(\"ANALIZA SK\u0141ADU CHEMICZNEGO - QM9 DATASET\")\nprint(\"=\"*70)\n\n# ============================================================\n# 1. ROZK\u0141AD ATOM\u00d3W (H, C, N, O, F)\n# ============================================================\n\nprint(\"\\n\ud83e\uddea ETAP 1: ROZK\u0141AD ATOM\u00d3W W DATASECIE\")\nprint(\"-\" * 70)\n\n# Funkcja do analizy sk\u0142adu\ndef get_atom_composition(smiles):\n    \"\"\"Zwraca s\u0142ownik z liczb\u0105 atom\u00f3w ka\u017cdego typu\"\"\"\n    from rdkit import Chem\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n\n    atom_dict = {'H': 0, 'C': 0, 'N': 0, 'O': 0, 'F': 0}\n    for atom in mol.GetAtoms():\n        symbol = atom.GetSymbol()\n        if symbol in atom_dict:\n            atom_dict[symbol] += 1\n\n    # Dodaj wodory (mog\u0105 by\u0107 jawne lub niejawne)\n    atom_dict['H'] = sum(1 for atom in mol.GetAtoms() if atom.GetSymbol() == 'H')\n    if atom_dict['H'] == 0:  # Je\u015bli wodory s\u0105 niejawne\n        atom_dict['H'] = sum(atom.GetTotalNumHs() for atom in mol.GetAtoms())\n\n    return atom_dict\n\n# Obliczenie sk\u0142adu dla wszystkich cz\u0105steczek\nprint(\"Analizuj\u0119 sk\u0142ad atomowy cz\u0105steczek...\")\ncompositions = df['SMILES'].apply(get_atom_composition)\ndf_composition = compositions.apply(pd.Series)\n\n# Dodanie do g\u0142\u00f3wnego DataFrame\ndf['H_count'] = df_composition['H']\ndf['C_count'] = df_composition['C']\ndf['N_count'] = df_composition['N']\ndf['O_count'] = df_composition['O']\ndf['F_count'] = df_composition['F']\n\nprint(\"\\n\ud83d\udcca Statystyki rozk\u0142adu atom\u00f3w:\")\nprint(\"-\" * 70)\n\natom_stats = df_composition.describe()\nprint(atom_stats)\n\n# Ca\u0142kowita liczba ka\u017cdego atomu w datasecie\nprint(\"\\n\ud83d\udcc8 Ca\u0142kowita liczba atom\u00f3w w datasecie:\")\nfor atom in ['H', 'C', 'N', 'O', 'F']:\n    total = df[f'{atom}_count'].sum()\n    avg_per_mol = df[f'{atom}_count'].mean()\n    print(f\"  \u2022 {atom}: {total:,} atom\u00f3w | \u015arednio {avg_per_mol:.2f} na cz\u0105steczk\u0119\")\n\n# ============================================================\n# 2. WIZUALIZACJA ROZK\u0141ADU ATOM\u00d3W\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udcca WIZUALIZACJA ROZK\u0141ADU ATOM\u00d3W\")\nprint(\"=\"*70)\n\nfig, axes = plt.subplots(2, 3, figsize=(18, 10))\naxes = axes.flatten()\n\natom_colors = {\n    'H': '#E8E8E8',  # Jasny szary (wod\u00f3r)\n    'C': '#909090',  # Ciemny szary (w\u0119giel)\n    'N': '#3050F8',  # Niebieski (azot)\n    'O': '#FF0D0D',  # Czerwony (tlen)\n    'F': '#90E050'   # Zielony (fluor)\n}\n\nfor i, atom in enumerate(['H', 'C', 'N', 'O', 'F']):\n    col = f'{atom}_count'\n    data = df[col].dropna()\n\n    axes[i].hist(data, bins=50, color=atom_colors[atom], \n                 edgecolor='black', alpha=0.7, linewidth=0.5)\n    axes[i].set_xlabel(f'Liczba atom\u00f3w {atom}', fontsize=11, fontweight='bold')\n    axes[i].set_ylabel('Liczba cz\u0105steczek', fontsize=11, fontweight='bold')\n    axes[i].set_title(f'Rozk\u0142ad atom\u00f3w {atom}\\n\u015arednia: {data.mean():.2f} | Max: {data.max():.0f}', \n                      fontsize=12, fontweight='bold')\n    axes[i].grid(axis='y', alpha=0.3)\n\n    # Dodanie linii mediany\n    median_val = data.median()\n    axes[i].axvline(median_val, color='red', linestyle='--', linewidth=2, \n                    label=f'Mediana: {median_val:.1f}')\n    axes[i].legend()\n\n# Wykres por\u00f3wnawczy - \u015brednie liczby atom\u00f3w\nax_comparison = axes[5]\natoms = ['H', 'C', 'N', 'O', 'F']\nmeans = [df[f'{atom}_count'].mean() for atom in atoms]\ncolors_list = [atom_colors[atom] for atom in atoms]\n\nbars = ax_comparison.bar(atoms, means, color=colors_list, \n                          edgecolor='black', linewidth=1.5, alpha=0.8)\nax_comparison.set_ylabel('\u015arednia liczba atom\u00f3w', fontsize=11, fontweight='bold')\nax_comparison.set_xlabel('Typ atomu', fontsize=11, fontweight='bold')\nax_comparison.set_title('\u015aredni sk\u0142ad atomowy cz\u0105steczek QM9', \n                        fontsize=12, fontweight='bold')\nax_comparison.grid(axis='y', alpha=0.3)\n\nfor bar, val in zip(bars, means):\n    ax_comparison.text(bar.get_x() + bar.get_width()/2, val + 0.2, \n                       f'{val:.2f}', ha='center', fontweight='bold', fontsize=11)\n\nplt.suptitle('Rozk\u0142ad atom\u00f3w w datasecie QM9', fontsize=16, fontweight='bold', y=1.00)\nplt.tight_layout()\nplt.savefig('qm9_atom_distribution.png', dpi=300, bbox_inches='tight')\nprint(\"\u2705 Zapisano: qm9_atom_distribution.png\")\nplt.show()\n\n# ============================================================\n# 3. MASA MOLOWA - SZCZEG\u00d3\u0141OWA ANALIZA\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\u2696\ufe0f  ANALIZA MASY MOLOWEJ\")\nprint(\"=\"*70)\n\n# Obliczenie masy molowej\nfrom rdkit.Chem import Descriptors\n\ndef calculate_molecular_weight(smiles):\n    from rdkit import Chem\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n    return Descriptors.MolWt(mol)\n\ndf['MolWt'] = df['SMILES'].apply(calculate_molecular_weight)\n\n# Statystyki\nprint(\"\\n\ud83d\udcca Statystyki masy molowej:\")\nprint(f\"  \u2022 \u015arednia:    {df['MolWt'].mean():.2f} g/mol\")\nprint(f\"  \u2022 Mediana:    {df['MolWt'].median():.2f} g/mol\")\nprint(f\"  \u2022 Odch. std:  {df['MolWt'].std():.2f} g/mol\")\nprint(f\"  \u2022 Min:        {df['MolWt'].min():.2f} g/mol\")\nprint(f\"  \u2022 Max:        {df['MolWt'].max():.2f} g/mol\")\n\n# Percentyle\nprint(\"\\n\ud83d\udcc8 Percentyle masy molowej:\")\npercentiles = [10, 25, 50, 75, 90, 95, 99]\nfor p in percentiles:\n    val = df['MolWt'].quantile(p/100)\n    print(f\"  \u2022 {p:2d}%:  {val:.2f} g/mol\")\n\n# Wizualizacja\nfig, axes = plt.subplots(1, 3, figsize=(18, 5))\n\n# 1. Histogram\naxes[0].hist(df['MolWt'], bins=60, color='steelblue', \n             edgecolor='black', alpha=0.7, linewidth=0.5)\naxes[0].axvline(df['MolWt'].mean(), color='red', linestyle='--', \n                linewidth=2, label=f\"\u015arednia: {df['MolWt'].mean():.1f}\")\naxes[0].axvline(df['MolWt'].median(), color='green', linestyle='--', \n                linewidth=2, label=f\"Mediana: {df['MolWt'].median():.1f}\")\naxes[0].set_xlabel('Masa molowa (g/mol)', fontsize=12, fontweight='bold')\naxes[0].set_ylabel('Liczba cz\u0105steczek', fontsize=12, fontweight='bold')\naxes[0].set_title('Rozk\u0142ad masy molowej', fontsize=13, fontweight='bold')\naxes[0].legend()\naxes[0].grid(axis='y', alpha=0.3)\n\n# 2. Boxplot\nbp = axes[1].boxplot([df['MolWt'].dropna()], labels=['Masa molowa'], \n                      patch_artist=True, widths=0.5)\nbp['boxes'][0].set_facecolor('lightblue')\nbp['boxes'][0].set_alpha(0.7)\naxes[1].set_ylabel('Masa molowa (g/mol)', fontsize=12, fontweight='bold')\naxes[1].set_title('Boxplot masy molowej', fontsize=13, fontweight='bold')\naxes[1].grid(axis='y', alpha=0.3)\n\n# 3. Dystrybuanta (CDF)\nsorted_mw = np.sort(df['MolWt'].dropna())\ncdf = np.arange(1, len(sorted_mw) + 1) / len(sorted_mw)\naxes[2].plot(sorted_mw, cdf, linewidth=2, color='darkblue')\naxes[2].set_xlabel('Masa molowa (g/mol)', fontsize=12, fontweight='bold')\naxes[2].set_ylabel('Dystrybuanta (CDF)', fontsize=12, fontweight='bold')\naxes[2].set_title('Dystrybuanta masy molowej', fontsize=13, fontweight='bold')\naxes[2].grid(alpha=0.3)\n\n# Dodanie linii percentyli\nfor p in [25, 50, 75]:\n    val = df['MolWt'].quantile(p/100)\n    axes[2].axvline(val, color='red', linestyle=':', alpha=0.5)\n    axes[2].text(val, 0.05, f'{p}%', rotation=90, fontsize=9)\n\nplt.tight_layout()\nplt.savefig('qm9_molecular_weight.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_molecular_weight.png\")\nplt.show()\n\n# ============================================================\n# 4. LICZBA ATOM\u00d3W CI\u0118\u017bKICH\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udd2c ANALIZA ATOM\u00d3W CI\u0118\u017bKICH (non-H)\")\nprint(\"=\"*70)\n\n# Obliczenie liczby atom\u00f3w ci\u0119\u017ckich\ndf['HeavyAtoms'] = df['C_count'] + df['N_count'] + df['O_count'] + df['F_count']\n\nprint(\"\\n\ud83d\udcca Statystyki atom\u00f3w ci\u0119\u017ckich:\")\nprint(f\"  \u2022 \u015arednia:   {df['HeavyAtoms'].mean():.2f} atom\u00f3w\")\nprint(f\"  \u2022 Mediana:   {df['HeavyAtoms'].median():.0f} atom\u00f3w\")\nprint(f\"  \u2022 Min:       {df['HeavyAtoms'].min():.0f} atom\u00f3w\")\nprint(f\"  \u2022 Max:       {df['HeavyAtoms'].max():.0f} atom\u00f3w\")\nprint(f\"  \u2022 Limit QM9: 9 atom\u00f3w ci\u0119\u017ckich\")\n\n# Rozk\u0142ad\nprint(\"\\n\ud83d\udcc8 Rozk\u0142ad liczby atom\u00f3w ci\u0119\u017ckich:\")\nheavy_dist = df['HeavyAtoms'].value_counts().sort_index()\nfor count, freq in heavy_dist.items():\n    pct = (freq / len(df)) * 100\n    bar = '\u2588' * int(pct / 2)\n    print(f\"  {count:2.0f} atom\u00f3w: {freq:6,} cz\u0105steczek ({pct:5.2f}%) {bar}\")\n\n# Wizualizacja\nfig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\n# Histogram\naxes[0].bar(heavy_dist.index, heavy_dist.values, color='coral', \n            edgecolor='black', alpha=0.8, linewidth=1)\naxes[0].set_xlabel('Liczba atom\u00f3w ci\u0119\u017ckich', fontsize=12, fontweight='bold')\naxes[0].set_ylabel('Liczba cz\u0105steczek', fontsize=12, fontweight='bold')\naxes[0].set_title('Rozk\u0142ad liczby atom\u00f3w ci\u0119\u017ckich\\n(QM9: max 9 atom\u00f3w)', \n                  fontsize=13, fontweight='bold')\naxes[0].grid(axis='y', alpha=0.3)\naxes[0].axvline(9, color='red', linestyle='--', linewidth=2, label='Limit QM9: 9')\naxes[0].legend()\n\n# Pie chart dla grup\nbins = [0, 3, 6, 9, 12]\nlabels = ['1-3 atomy', '4-6 atom\u00f3w', '7-9 atom\u00f3w', '10+ atom\u00f3w']\ndf['HeavyAtoms_bin'] = pd.cut(df['HeavyAtoms'], bins=bins, labels=labels[:len(bins)-1])\nheavy_grouped = df['HeavyAtoms_bin'].value_counts()\n\naxes[1].pie(heavy_grouped.values, labels=heavy_grouped.index, autopct='%1.1f%%',\n            colors=['#ff9999', '#66b3ff', '#99ff99'], startangle=90,\n            textprops={'fontsize': 11, 'fontweight': 'bold'})\naxes[1].set_title('Grupy wielko\u015bci moleku\u0142', fontsize=13, fontweight='bold')\n\nplt.tight_layout()\nplt.savefig('qm9_heavy_atoms.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_heavy_atoms.png\")\nplt.show()\n\n# ============================================================\n# 5. WZORY SUMARYCZNE - NAJCZ\u0118STSZE SK\u0141ADY\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83e\uddec WZORY SUMARYCZNE - NAJCZ\u0118STSZE SK\u0141ADY\")\nprint(\"=\"*70)\n\n# Tworzenie wzor\u00f3w sumarycznych\ndef create_formula(row):\n    \"\"\"Tworzy wz\u00f3r sumaryczny w formacie CxHyNzOaFb\"\"\"\n    parts = []\n    for atom in ['C', 'H', 'N', 'O', 'F']:\n        count = int(row[f'{atom}_count'])\n        if count &gt; 0:\n            if count == 1:\n                parts.append(atom)\n            else:\n                parts.append(f\"{atom}{count}\")\n    return ''.join(parts) if parts else \"Empty\"\n\ndf['MolecularFormula'] = df.apply(create_formula, axis=1)\n\n# Top 20 najcz\u0119stszych wzor\u00f3w\nprint(\"\\n\ud83c\udfc6 TOP 20 najcz\u0119stszych wzor\u00f3w sumarycznych:\")\nprint(\"-\" * 70)\n\ntop_formulas = df['MolecularFormula'].value_counts().head(20)\n\nfor i, (formula, count) in enumerate(top_formulas.items(), 1):\n    pct = (count / len(df)) * 100\n    print(f\"  {i:2d}. {formula:15s}  {count:4,} cz\u0105steczek ({pct:5.2f}%)\")\n\n# Wizualizacja top 15\nfig, axes = plt.subplots(1, 2, figsize=(16, 6))\n\n# Barplot\ntop15 = top_formulas.head(15)\naxes[0].barh(range(len(top15)), top15.values, color='teal', \n             edgecolor='black', alpha=0.7)\naxes[0].set_yticks(range(len(top15)))\naxes[0].set_yticklabels(top15.index, fontsize=9)\naxes[0].set_xlabel('Liczba cz\u0105steczek', fontsize=12, fontweight='bold')\naxes[0].set_title('Top 15 najcz\u0119stszych wzor\u00f3w sumarycznych', \n                  fontsize=13, fontweight='bold')\naxes[0].grid(axis='x', alpha=0.3)\naxes[0].invert_yaxis()\n\n# Dodanie warto\u015bci\nfor i, val in enumerate(top15.values):\n    axes[0].text(val + 5, i, f'{val}', va='center', fontsize=9, fontweight='bold')\n\n# Rozk\u0142ad unikalno\u015bci\nunique_formulas = df['MolecularFormula'].nunique()\ntotal_molecules = len(df)\n\ncategories = ['Unikalne wzory', 'Powtarzaj\u0105ce si\u0119']\nvalues = [unique_formulas, total_molecules - unique_formulas]\n\naxes[1].pie(values, labels=categories, autopct='%1.1f%%',\n            colors=['#ff6b6b', '#4ecdc4'], startangle=90,\n            textprops={'fontsize': 12, 'fontweight': 'bold'})\naxes[1].set_title(f'Unikalno\u015b\u0107 wzor\u00f3w sumarycznych\\n({unique_formulas:,} unikalnych / {total_molecules:,} total)', \n                  fontsize=13, fontweight='bold')\n\nplt.tight_layout()\nplt.savefig('qm9_molecular_formulas.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_molecular_formulas.png\")\nplt.show()\n\n# ============================================================\n# 6. PODSUMOWANIE SK\u0141ADU CHEMICZNEGO\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udccb PODSUMOWANIE SK\u0141ADU CHEMICZNEGO\")\nprint(\"=\"*70)\n\nprint(f\"\"\"\n\ud83e\uddea SK\u0141AD ATOMOWY:\n  \u2022 \u015arednia H:  {df['H_count'].mean():.2f} (wod\u00f3r)\n  \u2022 \u015arednia C:  {df['C_count'].mean():.2f} (w\u0119giel)\n  \u2022 \u015arednia N:  {df['N_count'].mean():.2f} (azot)\n  \u2022 \u015arednia O:  {df['O_count'].mean():.2f} (tlen)\n  \u2022 \u015arednia F:  {df['F_count'].mean():.2f} (fluor)\n\n\u2696\ufe0f  MASA MOLOWA:\n  \u2022 Zakres:     {df['MolWt'].min():.1f} - {df['MolWt'].max():.1f} g/mol\n  \u2022 \u015arednia:    {df['MolWt'].mean():.1f} g/mol\n  \u2022 Mediana:    {df['MolWt'].median():.1f} g/mol\n\n\ud83d\udd2c ATOMY CI\u0118\u017bKIE:\n  \u2022 Zakres:     {df['HeavyAtoms'].min():.0f} - {df['HeavyAtoms'].max():.0f} atom\u00f3w\n  \u2022 \u015arednia:    {df['HeavyAtoms'].mean():.2f} atom\u00f3w\n  \u2022 Limit QM9:  9 atom\u00f3w ci\u0119\u017ckich (spec datasetu)\n\n\ud83e\uddec WZORY SUMARYCZNE:\n  \u2022 Unikalne wzory:           {unique_formulas:,}\n  \u2022 Ca\u0142kowita liczba moleku\u0142: {total_molecules:,}\n  \u2022 Najcz\u0119stszy wz\u00f3r:         {top_formulas.index[0]} ({top_formulas.values[0]} moleku\u0142)\n\n\u2705 CHARAKTERYSTYKA DATASETU:\n  \u2022 QM9 zawiera ma\u0142e cz\u0105steczki organiczne (max 9 ci\u0119\u017ckich atom\u00f3w)\n  \u2022 Dominuj\u0105 zwi\u0105zki z H, C, N, O, F (jak w specyfikacji)\n  \u2022 Du\u017ca r\u00f3\u017cnorodno\u015b\u0107 strukturalna ({unique_formulas:,} unikalnych wzor\u00f3w)\n  \u2022 Masa molowa typowo poni\u017cej 150 g/mol (small molecules)\n\"\"\")\n\nprint(\"=\"*70)\nprint(\"\u2705 ANALIZA SK\u0141ADU CHEMICZNEGO ZAKO\u0143CZONA!\")\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nANALIZA SK\u0141ADU CHEMICZNEGO - QM9 DATASET\n======================================================================\n\n\ud83e\uddea ETAP 1: ROZK\u0141AD ATOM\u00d3W W DATASECIE\n----------------------------------------------------------------------\nAnalizuj\u0119 sk\u0142ad atomowy cz\u0105steczek...\n\n\ud83d\udcca Statystyki rozk\u0142adu atom\u00f3w:\n----------------------------------------------------------------------\n                 H            C            N            O            F\ncount  1000.000000  1000.000000  1000.000000  1000.000000  1000.000000\nmean      9.322000     6.251000     1.093000     1.392000     0.020000\nstd       3.103215     1.282046     1.138265     0.875844     0.188774\nmin       1.000000     2.000000     0.000000     0.000000     0.000000\n25%       7.000000     5.000000     0.000000     1.000000     0.000000\n50%       9.000000     6.000000     1.000000     1.000000     0.000000\n75%      12.000000     7.000000     2.000000     2.000000     0.000000\nmax      18.000000     9.000000     6.000000     4.000000     3.000000\n\n\ud83d\udcc8 Ca\u0142kowita liczba atom\u00f3w w datasecie:\n  \u2022 H: 9,322 atom\u00f3w | \u015arednio 9.32 na cz\u0105steczk\u0119\n  \u2022 C: 6,251 atom\u00f3w | \u015arednio 6.25 na cz\u0105steczk\u0119\n  \u2022 N: 1,093 atom\u00f3w | \u015arednio 1.09 na cz\u0105steczk\u0119\n  \u2022 O: 1,392 atom\u00f3w | \u015arednio 1.39 na cz\u0105steczk\u0119\n  \u2022 F: 20 atom\u00f3w | \u015arednio 0.02 na cz\u0105steczk\u0119\n\n======================================================================\n\ud83d\udcca WIZUALIZACJA ROZK\u0141ADU ATOM\u00d3W\n======================================================================\n\u2705 Zapisano: qm9_atom_distribution.png\n</pre> <pre>\n======================================================================\n\u2696\ufe0f  ANALIZA MASY MOLOWEJ\n======================================================================\n\n\ud83d\udcca Statystyki masy molowej:\n  \u2022 \u015arednia:    122.53 g/mol\n  \u2022 Mediana:    125.13 g/mol\n  \u2022 Odch. std:  8.67 g/mol\n  \u2022 Min:        59.07 g/mol\n  \u2022 Max:        142.12 g/mol\n\n\ud83d\udcc8 Percentyle masy molowej:\n  \u2022 10%:  112.11 g/mol\n  \u2022 25%:  121.10 g/mol\n  \u2022 50%:  125.13 g/mol\n  \u2022 75%:  128.13 g/mol\n  \u2022 90%:  130.08 g/mol\n  \u2022 95%:  131.13 g/mol\n  \u2022 99%:  132.20 g/mol\n</pre> <pre>C:\\Users\\slast\\AppData\\Local\\Temp\\ipykernel_6436\\3117465052.py:175: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  bp = axes[1].boxplot([df['MolWt'].dropna()], labels=['Masa molowa'],\n</pre> <pre>\n\u2705 Zapisano: qm9_molecular_weight.png\n</pre> <pre>\n======================================================================\n\ud83d\udd2c ANALIZA ATOM\u00d3W CI\u0118\u017bKICH (non-H)\n======================================================================\n\n\ud83d\udcca Statystyki atom\u00f3w ci\u0119\u017ckich:\n  \u2022 \u015arednia:   8.76 atom\u00f3w\n  \u2022 Mediana:   9 atom\u00f3w\n  \u2022 Min:       4 atom\u00f3w\n  \u2022 Max:       9 atom\u00f3w\n  \u2022 Limit QM9: 9 atom\u00f3w ci\u0119\u017ckich\n\n\ud83d\udcc8 Rozk\u0142ad liczby atom\u00f3w ci\u0119\u017ckich:\n   4 atom\u00f3w:      1 cz\u0105steczek ( 0.10%) \n   5 atom\u00f3w:      2 cz\u0105steczek ( 0.20%) \n   6 atom\u00f3w:      8 cz\u0105steczek ( 0.80%) \n   7 atom\u00f3w:     30 cz\u0105steczek ( 3.00%) \u2588\n   8 atom\u00f3w:    147 cz\u0105steczek (14.70%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\n   9 atom\u00f3w:    812 cz\u0105steczek (81.20%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\n\u2705 Zapisano: qm9_heavy_atoms.png\n</pre> <pre>\n======================================================================\n\ud83e\uddec WZORY SUMARYCZNE - NAJCZ\u0118STSZE SK\u0141ADY\n======================================================================\n\n\ud83c\udfc6 TOP 20 najcz\u0119stszych wzor\u00f3w sumarycznych:\n----------------------------------------------------------------------\n   1. C7H10O2            52 cz\u0105steczek ( 5.20%)\n   2. C6H9NO2            39 cz\u0105steczek ( 3.90%)\n   3. C7H12O2            36 cz\u0105steczek ( 3.60%)\n   4. C8H12O             35 cz\u0105steczek ( 3.50%)\n   5. C7H9NO             25 cz\u0105steczek ( 2.50%)\n   6. C6H8O3             23 cz\u0105steczek ( 2.30%)\n   7. C8H10O             21 cz\u0105steczek ( 2.10%)\n   8. C6H7NO2            19 cz\u0105steczek ( 1.90%)\n   9. C7H8O2             19 cz\u0105steczek ( 1.90%)\n  10. C7H14NO            18 cz\u0105steczek ( 1.80%)\n  11. C6H10N2O           17 cz\u0105steczek ( 1.70%)\n  12. C6H10O3            16 cz\u0105steczek ( 1.60%)\n  13. C7H12NO            15 cz\u0105steczek ( 1.50%)\n  14. C8H14O             14 cz\u0105steczek ( 1.40%)\n  15. C6H8N2O            14 cz\u0105steczek ( 1.40%)\n  16. C6H11NO2           13 cz\u0105steczek ( 1.30%)\n  17. C6H12O3            13 cz\u0105steczek ( 1.30%)\n  18. C8H16O             12 cz\u0105steczek ( 1.20%)\n  19. C7H7NO             12 cz\u0105steczek ( 1.20%)\n  20. C9H14              11 cz\u0105steczek ( 1.10%)\n\n\u2705 Zapisano: qm9_molecular_formulas.png\n</pre> <pre>\n======================================================================\n\ud83d\udccb PODSUMOWANIE SK\u0141ADU CHEMICZNEGO\n======================================================================\n\n\ud83e\uddea SK\u0141AD ATOMOWY:\n  \u2022 \u015arednia H:  9.32 (wod\u00f3r)\n  \u2022 \u015arednia C:  6.25 (w\u0119giel)\n  \u2022 \u015arednia N:  1.09 (azot)\n  \u2022 \u015arednia O:  1.39 (tlen)\n  \u2022 \u015arednia F:  0.02 (fluor)\n\n\u2696\ufe0f  MASA MOLOWA:\n  \u2022 Zakres:     59.1 - 142.1 g/mol\n  \u2022 \u015arednia:    122.5 g/mol\n  \u2022 Mediana:    125.1 g/mol\n\n\ud83d\udd2c ATOMY CI\u0118\u017bKIE:\n  \u2022 Zakres:     4 - 9 atom\u00f3w\n  \u2022 \u015arednia:    8.76 atom\u00f3w\n  \u2022 Limit QM9:  9 atom\u00f3w ci\u0119\u017ckich (spec datasetu)\n\n\ud83e\uddec WZORY SUMARYCZNE:\n  \u2022 Unikalne wzory:           243\n  \u2022 Ca\u0142kowita liczba moleku\u0142: 1,000\n  \u2022 Najcz\u0119stszy wz\u00f3r:         C7H10O2 (52 moleku\u0142)\n\n\u2705 CHARAKTERYSTYKA DATASETU:\n  \u2022 QM9 zawiera ma\u0142e cz\u0105steczki organiczne (max 9 ci\u0119\u017ckich atom\u00f3w)\n  \u2022 Dominuj\u0105 zwi\u0105zki z H, C, N, O, F (jak w specyfikacji)\n  \u2022 Du\u017ca r\u00f3\u017cnorodno\u015b\u0107 strukturalna (243 unikalnych wzor\u00f3w)\n  \u2022 Masa molowa typowo poni\u017cej 150 g/mol (small molecules)\n\n======================================================================\n\u2705 ANALIZA SK\u0141ADU CHEMICZNEGO ZAKO\u0143CZONA!\n======================================================================\n</pre> In\u00a0[25]: <pre># ============================================================\n# KOM\u00d3RKA 10: ANALIZA STRUKTURALNA\n# ============================================================\n\nprint(\"=\"*70)\nprint(\"ANALIZA STRUKTURALNA - QM9 DATASET\")\nprint(\"=\"*70)\n\n# ============================================================\n# 1. ANALIZA WI\u0104ZA\u0143 (SINGLE, DOUBLE, TRIPLE, AROMATIC)\n# ============================================================\n\nprint(\"\\n\ud83d\udd17 ETAP 1: ANALIZA TYP\u00d3W WI\u0104ZA\u0143\")\nprint(\"-\" * 70)\n\nfrom rdkit import Chem\nfrom rdkit.Chem import rdMolDescriptors, Descriptors\n\ndef analyze_bonds(smiles):\n    \"\"\"Analiza typ\u00f3w wi\u0105za\u0144 w cz\u0105steczce\"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n\n    bond_types = {\n        'single': 0,\n        'double': 0,\n        'triple': 0,\n        'aromatic': 0\n    }\n\n    for bond in mol.GetBonds():\n        bond_type = bond.GetBondType()\n        if bond_type == Chem.BondType.SINGLE:\n            if not bond.GetIsAromatic():\n                bond_types['single'] += 1\n        elif bond_type == Chem.BondType.DOUBLE:\n            if not bond.GetIsAromatic():\n                bond_types['double'] += 1\n        elif bond_type == Chem.BondType.TRIPLE:\n            bond_types['triple'] += 1\n\n        if bond.GetIsAromatic():\n            bond_types['aromatic'] += 1\n\n    return bond_types\n\nprint(\"Analizuj\u0119 typy wi\u0105za\u0144 w cz\u0105steczkach...\")\nbonds_data = df['SMILES'].apply(analyze_bonds)\ndf_bonds = bonds_data.apply(pd.Series)\n\n# Dodanie do g\u0142\u00f3wnego DataFrame\ndf['single_bonds'] = df_bonds['single']\ndf['double_bonds'] = df_bonds['double']\ndf['triple_bonds'] = df_bonds['triple']\ndf['aromatic_bonds'] = df_bonds['aromatic']\n\nprint(\"\\n\ud83d\udcca Statystyki typ\u00f3w wi\u0105za\u0144:\")\nprint(df_bonds.describe())\n\nprint(\"\\n\ud83d\udcc8 \u015arednia liczba wi\u0105za\u0144 ka\u017cdego typu:\")\nfor bond_type in ['single', 'double', 'triple', 'aromatic']:\n    avg = df[f'{bond_type}_bonds'].mean()\n    total = df[f'{bond_type}_bonds'].sum()\n    molecules_with = (df[f'{bond_type}_bonds'] &gt; 0).sum()\n    pct = (molecules_with / len(df)) * 100\n    print(f\"  \u2022 {bond_type:10s}: \u015arednio {avg:.2f} | Moleku\u0142y z tym wi\u0105zaniem: {molecules_with:,} ({pct:.1f}%)\")\n\n# Wizualizacja\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\n\nbond_colors = {\n    'single': '#3498db',\n    'double': '#e74c3c',\n    'triple': '#f39c12',\n    'aromatic': '#9b59b6'\n}\n\nfor idx, (bond_type, ax) in enumerate(zip(['single', 'double', 'triple', 'aromatic'], axes.flatten())):\n    data = df[f'{bond_type}_bonds'].dropna()\n    ax.hist(data, bins=40, color=bond_colors[bond_type], \n            edgecolor='black', alpha=0.7, linewidth=0.5)\n    ax.set_xlabel(f'Liczba wi\u0105za\u0144 {bond_type}', fontsize=11, fontweight='bold')\n    ax.set_ylabel('Liczba cz\u0105steczek', fontsize=11, fontweight='bold')\n    ax.set_title(f'Rozk\u0142ad wi\u0105za\u0144 {bond_type}\\n\u015arednia: {data.mean():.2f}', \n                 fontsize=12, fontweight='bold')\n    ax.grid(axis='y', alpha=0.3)\n    ax.axvline(data.mean(), color='red', linestyle='--', linewidth=2, label='\u015arednia')\n    ax.legend()\n\nplt.suptitle('Rozk\u0142ad typ\u00f3w wi\u0105za\u0144 w QM9', fontsize=16, fontweight='bold')\nplt.tight_layout()\nplt.savefig('qm9_bond_types.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_bond_types.png\")\nplt.show()\n\n# ============================================================\n# 2. LICZBA PIER\u015aCIENI\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\u2b55 ANALIZA PIER\u015aCIENI\")\nprint(\"=\"*70)\n\ndef analyze_rings(smiles):\n    \"\"\"Szczeg\u00f3\u0142owa analiza pier\u015bcieni\"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n\n    return {\n        'total_rings': rdMolDescriptors.CalcNumRings(mol),\n        'aromatic_rings': rdMolDescriptors.CalcNumAromaticRings(mol),\n        'aliphatic_rings': rdMolDescriptors.CalcNumAliphaticRings(mol),\n        'saturated_rings': rdMolDescriptors.CalcNumSaturatedRings(mol),\n        'hetero_rings': rdMolDescriptors.CalcNumHeterocycles(mol),\n        'aromatic_hetero_rings': rdMolDescriptors.CalcNumAromaticHeterocycles(mol)\n    }\n\nprint(\"Analizuj\u0119 struktury pier\u015bcieniowe...\")\nrings_data = df['SMILES'].apply(analyze_rings)\ndf_rings = rings_data.apply(pd.Series)\n\n# Dodanie do g\u0142\u00f3wnego DataFrame\nfor col in df_rings.columns:\n    df[col] = df_rings[col]\n\nprint(\"\\n\ud83d\udcca Statystyki pier\u015bcieni:\")\nprint(df_rings.describe())\n\n# Rozk\u0142ad liczby pier\u015bcieni\nprint(\"\\n\ud83d\udcc8 Rozk\u0142ad liczby pier\u015bcieni:\")\nring_dist = df['total_rings'].value_counts().sort_index()\nfor count, freq in ring_dist.items():\n    pct = (freq / len(df)) * 100\n    bar = '\u2588' * int(pct / 3)\n    print(f\"  {count:1.0f} pier\u015bcieni: {freq:6,} cz\u0105steczek ({pct:5.2f}%) {bar}\")\n\n# Moleku\u0142y z/bez pier\u015bcieni\nmolecules_with_rings = (df['total_rings'] &gt; 0).sum()\nmolecules_without_rings = (df['total_rings'] == 0).sum()\nprint(f\"\\n\u2713 Z pier\u015bcieniami:    {molecules_with_rings:,} ({molecules_with_rings/len(df)*100:.1f}%)\")\nprint(f\"\u2713 Bez pier\u015bcieni:     {molecules_without_rings:,} ({molecules_without_rings/len(df)*100:.1f}%)\")\n\n# Wizualizacja\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\n\n# 1. Histogram liczby pier\u015bcieni\naxes[0, 0].bar(ring_dist.index, ring_dist.values, color='steelblue', \n               edgecolor='black', alpha=0.8, linewidth=1)\naxes[0, 0].set_xlabel('Liczba pier\u015bcieni', fontsize=12, fontweight='bold')\naxes[0, 0].set_ylabel('Liczba cz\u0105steczek', fontsize=12, fontweight='bold')\naxes[0, 0].set_title('Rozk\u0142ad liczby pier\u015bcieni', fontsize=13, fontweight='bold')\naxes[0, 0].grid(axis='y', alpha=0.3)\n\n# 2. Pie chart - z/bez pier\u015bcieni\naxes[0, 1].pie([molecules_with_rings, molecules_without_rings],\n               labels=['Z pier\u015bcieniami', 'Bez pier\u015bcieni'],\n               autopct='%1.1f%%', colors=['#3498db', '#95a5a6'],\n               startangle=90, textprops={'fontsize': 11, 'fontweight': 'bold'})\naxes[0, 1].set_title('Obecno\u015b\u0107 pier\u015bcieni', fontsize=13, fontweight='bold')\n\n# 3. Aromatyczne vs Alifatyczne\nring_types = ['aromatic_rings', 'aliphatic_rings', 'saturated_rings']\nring_labels = ['Aromatyczne', 'Alifatyczne', 'Nasycone']\nring_colors = ['#e74c3c', '#2ecc71', '#f39c12']\n\nfor ring_type, label, color in zip(ring_types, ring_labels, ring_colors):\n    data = df[ring_type].value_counts().sort_index()\n    axes[1, 0].plot(data.index, data.values, marker='o', linewidth=2, \n                    label=label, color=color, markersize=8)\n\naxes[1, 0].set_xlabel('Liczba pier\u015bcieni', fontsize=12, fontweight='bold')\naxes[1, 0].set_ylabel('Liczba cz\u0105steczek', fontsize=12, fontweight='bold')\naxes[1, 0].set_title('Typy pier\u015bcieni', fontsize=13, fontweight='bold')\naxes[1, 0].legend()\naxes[1, 0].grid(alpha=0.3)\n\n# 4. Heterocykle\nhetero_dist = df['hetero_rings'].value_counts().sort_index()\naxes[1, 1].bar(hetero_dist.index, hetero_dist.values, color='#9b59b6', \n               edgecolor='black', alpha=0.8, linewidth=1)\naxes[1, 1].set_xlabel('Liczba heterocykli', fontsize=12, fontweight='bold')\naxes[1, 1].set_ylabel('Liczba cz\u0105steczek', fontsize=12, fontweight='bold')\naxes[1, 1].set_title('Rozk\u0142ad heterocykli', fontsize=13, fontweight='bold')\naxes[1, 1].grid(axis='y', alpha=0.3)\n\nplt.suptitle('Analiza struktur pier\u015bcieniowych', fontsize=16, fontweight='bold')\nplt.tight_layout()\nplt.savefig('qm9_rings_analysis.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_rings_analysis.png\")\nplt.show()\n\n# ============================================================\n# 3. ROTOWALNE WI\u0104ZANIA (FLEXIBILITY)\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udd04 ANALIZA ROTOWALNYCH WI\u0104ZA\u0143 (FLEXIBILITY)\")\nprint(\"=\"*70)\n\ndef calculate_rotatable_bonds(smiles):\n    \"\"\"Oblicza liczb\u0119 rotowalnych wi\u0105za\u0144\"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n    return rdMolDescriptors.CalcNumRotatableBonds(mol)\n\ndf['rotatable_bonds'] = df['SMILES'].apply(calculate_rotatable_bonds)\n\nprint(\"\\n\ud83d\udcca Statystyki rotowalnych wi\u0105za\u0144:\")\nprint(f\"  \u2022 \u015arednia:   {df['rotatable_bonds'].mean():.2f} wi\u0105za\u0144\")\nprint(f\"  \u2022 Mediana:   {df['rotatable_bonds'].median():.0f} wi\u0105za\u0144\")\nprint(f\"  \u2022 Max:       {df['rotatable_bonds'].max():.0f} wi\u0105za\u0144\")\nprint(f\"  \u2022 Std:       {df['rotatable_bonds'].std():.2f}\")\n\n# Rozk\u0142ad\nprint(\"\\n\ud83d\udcc8 Rozk\u0142ad rotowalnych wi\u0105za\u0144:\")\nrotatable_dist = df['rotatable_bonds'].value_counts().sort_index()\nfor count, freq in rotatable_dist.items():\n    pct = (freq / len(df)) * 100\n    if pct &gt; 1:  # Poka\u017c tylko istotne\n        bar = '\u2588' * int(pct / 2)\n        print(f\"  {count:2.0f} wi\u0105za\u0144: {freq:6,} cz\u0105steczek ({pct:5.2f}%) {bar}\")\n\n# Klasyfikacja flexibility\nrigid = (df['rotatable_bonds'] == 0).sum()\nsemi_flexible = ((df['rotatable_bonds'] &gt; 0) &amp; (df['rotatable_bonds'] &lt;= 3)).sum()\nflexible = (df['rotatable_bonds'] &gt; 3).sum()\n\nprint(f\"\\n\ud83d\udccb Klasyfikacja elastyczno\u015bci:\")\nprint(f\"  \u2022 Sztywne (0 wi\u0105za\u0144):        {rigid:,} ({rigid/len(df)*100:.1f}%)\")\nprint(f\"  \u2022 Semi-elastyczne (1-3):     {semi_flexible:,} ({semi_flexible/len(df)*100:.1f}%)\")\nprint(f\"  \u2022 Elastyczne (4+):           {flexible:,} ({flexible/len(df)*100:.1f}%)\")\n\n# Wizualizacja\nfig, axes = plt.subplots(1, 3, figsize=(18, 5))\n\n# 1. Histogram\naxes[0].hist(df['rotatable_bonds'], bins=range(0, int(df['rotatable_bonds'].max())+2), \n             color='teal', edgecolor='black', alpha=0.7)\naxes[0].axvline(df['rotatable_bonds'].mean(), color='red', linestyle='--', \n                linewidth=2, label=f\"\u015arednia: {df['rotatable_bonds'].mean():.2f}\")\naxes[0].set_xlabel('Liczba rotowalnych wi\u0105za\u0144', fontsize=12, fontweight='bold')\naxes[0].set_ylabel('Liczba cz\u0105steczek', fontsize=12, fontweight='bold')\naxes[0].set_title('Rozk\u0142ad rotowalnych wi\u0105za\u0144', fontsize=13, fontweight='bold')\naxes[0].legend()\naxes[0].grid(axis='y', alpha=0.3)\n\n# 2. Pie chart - klasyfikacja\nflexibility_labels = ['Sztywne\\n(0)', 'Semi-elastyczne\\n(1-3)', 'Elastyczne\\n(4+)']\nflexibility_values = [rigid, semi_flexible, flexible]\nflexibility_colors = ['#e74c3c', '#f39c12', '#2ecc71']\n\naxes[1].pie(flexibility_values, labels=flexibility_labels, autopct='%1.1f%%',\n            colors=flexibility_colors, startangle=90,\n            textprops={'fontsize': 11, 'fontweight': 'bold'})\naxes[1].set_title('Klasyfikacja elastyczno\u015bci moleku\u0142', fontsize=13, fontweight='bold')\n\n# 3. Zale\u017cno\u015b\u0107: rotatable bonds vs masa molowa\naxes[2].scatter(df['MolWt'], df['rotatable_bonds'], alpha=0.3, s=10, color='darkblue')\naxes[2].set_xlabel('Masa molowa (g/mol)', fontsize=12, fontweight='bold')\naxes[2].set_ylabel('Liczba rotowalnych wi\u0105za\u0144', fontsize=12, fontweight='bold')\naxes[2].set_title('Elastyczno\u015b\u0107 vs Masa molowa', fontsize=13, fontweight='bold')\naxes[2].grid(alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('qm9_rotatable_bonds.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_rotatable_bonds.png\")\nplt.show()\n\n# ============================================================\n# ============================================================\n# 4. FRAKCJA SP3 (SATURACJA VS AROMATYCZNO\u015a\u0106)\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83e\uddec ANALIZA FRAKCJI SP3 (SATURACJA)\")\nprint(\"=\"*70)\n\ndef calculate_sp3_fraction(smiles):\n    \"\"\"Oblicza frakcj\u0119 w\u0119gli sp3\"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n\n    # Liczba w\u0119gli sp3\n    num_sp3 = 0\n    num_carbon = 0\n\n    for atom in mol.GetAtoms():\n        if atom.GetSymbol() == 'C':\n            num_carbon += 1\n            if atom.GetHybridization() == Chem.HybridizationType.SP3:\n                num_sp3 += 1\n\n    if num_carbon == 0:\n        return 0.0\n\n    return num_sp3 / num_carbon\n\ndf['frac_csp3'] = df['SMILES'].apply(calculate_sp3_fraction)\n\n# ============================================================\n# 5. CHIRALNO\u015a\u0106\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udd00 ANALIZA CHIRALNO\u015aCI\")\nprint(\"=\"*70)\n\ndef analyze_chirality(smiles):\n    \"\"\"Analiza centr\u00f3w chiralnych\"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n\n    # Znajd\u017a centra chiralne\n    Chem.AssignStereochemistry(mol, cleanIt=True, force=True)\n    chiral_centers = Chem.FindMolChiralCenters(mol, includeUnassigned=True)\n\n    return {\n        'num_chiral_centers': len(chiral_centers),\n        'has_chirality': len(chiral_centers) &gt; 0\n    }\n\nprint(\"Analizuj\u0119 centra chiralne...\")\nchirality_data = df['SMILES'].apply(analyze_chirality)\ndf_chirality = chirality_data.apply(pd.Series)\n\ndf['num_chiral_centers'] = df_chirality['num_chiral_centers']\ndf['has_chirality'] = df_chirality['has_chirality']\n\n# Statystyki\nchiral_molecules = df['has_chirality'].sum()\nachiral_molecules = (~df['has_chirality']).sum()\n\nprint(f\"\\n\ud83d\udcca Statystyki chiralno\u015bci:\")\nprint(f\"  \u2022 Cz\u0105steczki chiralne:    {chiral_molecules:,} ({chiral_molecules/len(df)*100:.1f}%)\")\nprint(f\"  \u2022 Cz\u0105steczki achiralne:   {achiral_molecules:,} ({achiral_molecules/len(df)*100:.1f}%)\")\n\nprint(f\"\\n\ud83d\udcc8 Rozk\u0142ad liczby centr\u00f3w chiralnych:\")\nchiral_dist = df['num_chiral_centers'].value_counts().sort_index()\nfor count, freq in chiral_dist.items():\n    pct = (freq / len(df)) * 100\n    if pct &gt; 0.5:\n        bar = '\u2588' * int(pct / 2)\n        print(f\"  {count:1.0f} centr\u00f3w: {freq:6,} cz\u0105steczek ({pct:5.2f}%) {bar}\")\n\n# Wizualizacja\nfig, axes = plt.subplots(1, 3, figsize=(18, 5))\n\n# 1. Pie chart - chiralne vs achiralne\naxes[0].pie([chiral_molecules, achiral_molecules],\n            labels=['Chiralne', 'Achiralne'],\n            autopct='%1.1f%%', colors=['#e74c3c', '#95a5a6'],\n            startangle=90, textprops={'fontsize': 12, 'fontweight': 'bold'})\naxes[0].set_title('Obecno\u015b\u0107 chiralno\u015bci', fontsize=13, fontweight='bold')\n\n# 2. Histogram liczby centr\u00f3w\nchiral_only = df[df['has_chirality']]\nif len(chiral_only) &gt; 0:\n    axes[1].hist(chiral_only['num_chiral_centers'], \n                 bins=range(0, int(chiral_only['num_chiral_centers'].max())+2),\n                 color='coral', edgecolor='black', alpha=0.7)\n    axes[1].set_xlabel('Liczba centr\u00f3w chiralnych', fontsize=12, fontweight='bold')\n    axes[1].set_ylabel('Liczba cz\u0105steczek', fontsize=12, fontweight='bold')\n    axes[1].set_title('Rozk\u0142ad centr\u00f3w chiralnych\\n(tylko moleku\u0142y chiralne)', \n                      fontsize=13, fontweight='bold')\n    axes[1].grid(axis='y', alpha=0.3)\n\n# 3. Chiralno\u015b\u0107 vs z\u0142o\u017cono\u015b\u0107\naxes[2].scatter(df['HeavyAtoms'], df['num_chiral_centers'], alpha=0.3, s=10, color='darkred')\naxes[2].set_xlabel('Liczba atom\u00f3w ci\u0119\u017ckich', fontsize=12, fontweight='bold')\naxes[2].set_ylabel('Liczba centr\u00f3w chiralnych', fontsize=12, fontweight='bold')\naxes[2].set_title('Chiralno\u015b\u0107 vs Z\u0142o\u017cono\u015b\u0107 moleku\u0142y', fontsize=13, fontweight='bold')\naxes[2].grid(alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('qm9_chirality.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_chirality.png\")\nplt.show()\n\n# ============================================================\n# 6. PODSUMOWANIE STRUKTURALNE\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udccb PODSUMOWANIE ANALIZY STRUKTURALNEJ\")\nprint(\"=\"*70)\n\nprint(f\"\"\"\n\ud83d\udd17 WI\u0104ZANIA:\n  \u2022 Single:     \u015arednio {df['single_bonds'].mean():.2f} wi\u0105za\u0144\n  \u2022 Double:     \u015arednio {df['double_bonds'].mean():.2f} wi\u0105za\u0144\n  \u2022 Triple:     \u015arednio {df['triple_bonds'].mean():.2f} wi\u0105za\u0144\n  \u2022 Aromatic:   \u015arednio {df['aromatic_bonds'].mean():.2f} wi\u0105za\u0144\n\n\u2b55 PIER\u015aCIENIE:\n  \u2022 \u015arednia liczba pier\u015bcieni:        {df['total_rings'].mean():.2f}\n  \u2022 Moleku\u0142y z pier\u015bcieniami:          {molecules_with_rings:,} ({molecules_with_rings/len(df)*100:.1f}%)\n  \u2022 \u015arednia pier\u015bcieni aromatycznych:  {df['aromatic_rings'].mean():.2f}\n  \u2022 \u015arednia heterocykli:               {df['hetero_rings'].mean():.2f}\n\n\ud83d\udd04 FLEXIBILITY:\n  \u2022 \u015arednia rotowalnych wi\u0105za\u0144:  {df['rotatable_bonds'].mean():.2f}\n  \u2022 Moleku\u0142y sztywne (0):        {rigid:,} ({rigid/len(df)*100:.1f}%)\n  \u2022 Moleku\u0142y elastyczne (4+):    {flexible:,} ({flexible/len(df)*100:.1f}%)\n\n\ud83e\uddec NASYCENIE:\n  \u2022 \u015arednia frakcja sp\u00b3:         {df['frac_csp3'].mean():.3f}\n  \u2022 Min frakcja sp\u00b3:             {df['frac_csp3'].min():.3f}\n  \u2022 Max frakcja sp\u00b3:             {df['frac_csp3'].max():.3f}\n\n\ud83d\udd00 CHIRALNO\u015a\u0106:\n  \u2022 Moleku\u0142y chiralne:           {chiral_molecules:,} ({chiral_molecules/len(df)*100:.1f}%)\n  \u2022 \u015arednia centr\u00f3w chiralnych:  {df['num_chiral_centers'].mean():.2f}\n\n\u2705 CHARAKTERYSTYKA:\n  \u2022 QM9 zawiera g\u0142\u00f3wnie ma\u0142e, wzgl\u0119dnie sztywne moleku\u0142y\n  \u2022 Dominuj\u0105 struktury z 0-2 pier\u015bcieniami\n  \u2022 Mix moleku\u0142 aromatycznych i alifatycznych\n  \u2022 Niska chiralno\u015b\u0107 (typowe dla ma\u0142ych moleku\u0142)\n\"\"\")\n\nprint(\"=\"*70)\nprint(\"\u2705 ANALIZA STRUKTURALNA ZAKO\u0143CZONA!\")\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nANALIZA STRUKTURALNA - QM9 DATASET\n======================================================================\n\n\ud83d\udd17 ETAP 1: ANALIZA TYP\u00d3W WI\u0104ZA\u0143\n----------------------------------------------------------------------\nAnalizuj\u0119 typy wi\u0105za\u0144 w cz\u0105steczkach...\n\n\ud83d\udcca Statystyki typ\u00f3w wi\u0105za\u0144:\n            single       double       triple     aromatic\ncount  1000.000000  1000.000000  1000.000000  1000.000000\nmean      7.502000     0.613000     0.268000     0.974000\nstd       2.624287     0.749528     0.548157     2.129756\nmin       0.000000     0.000000     0.000000     0.000000\n25%       6.000000     0.000000     0.000000     0.000000\n50%       8.000000     0.000000     0.000000     0.000000\n75%       9.000000     1.000000     0.000000     0.000000\nmax      13.000000     3.000000     4.000000    10.000000\n\n\ud83d\udcc8 \u015arednia liczba wi\u0105za\u0144 ka\u017cdego typu:\n  \u2022 single    : \u015arednio 7.50 | Moleku\u0142y z tym wi\u0105zaniem: 997 (99.7%)\n  \u2022 double    : \u015arednio 0.61 | Moleku\u0142y z tym wi\u0105zaniem: 472 (47.2%)\n  \u2022 triple    : \u015arednio 0.27 | Moleku\u0142y z tym wi\u0105zaniem: 222 (22.2%)\n  \u2022 aromatic  : \u015arednio 0.97 | Moleku\u0142y z tym wi\u0105zaniem: 179 (17.9%)\n\n\u2705 Zapisano: qm9_bond_types.png\n</pre> <pre>\n======================================================================\n\u2b55 ANALIZA PIER\u015aCIENI\n======================================================================\nAnalizuj\u0119 struktury pier\u015bcieniowe...\n\n\ud83d\udcca Statystyki pier\u015bcieni:\n       total_rings  aromatic_rings  aliphatic_rings  saturated_rings  \\\ncount  1000.000000     1000.000000      1000.000000      1000.000000   \nmean      1.696000        0.189000         1.507000         1.333000   \nstd       1.153653        0.416476         1.282028         1.302231   \nmin       0.000000        0.000000         0.000000         0.000000   \n25%       1.000000        0.000000         1.000000         0.000000   \n50%       1.000000        0.000000         1.000000         1.000000   \n75%       2.000000        0.000000         2.000000         2.000000   \nmax       7.000000        2.000000         7.000000         7.000000   \n\n       hetero_rings  aromatic_hetero_rings  \ncount   1000.000000            1000.000000  \nmean       1.018000               0.188000  \nstd        0.893574               0.415727  \nmin        0.000000               0.000000  \n25%        0.000000               0.000000  \n50%        1.000000               0.000000  \n75%        1.000000               0.000000  \nmax        6.000000               2.000000  \n\n\ud83d\udcc8 Rozk\u0142ad liczby pier\u015bcieni:\n  0 pier\u015bcieni:     98 cz\u0105steczek ( 9.80%) \u2588\u2588\u2588\n  1 pier\u015bcieni:    420 cz\u0105steczek (42.00%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  2 pier\u015bcieni:    271 cz\u0105steczek (27.10%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  3 pier\u015bcieni:    146 cz\u0105steczek (14.60%) \u2588\u2588\u2588\u2588\n  4 pier\u015bcieni:     38 cz\u0105steczek ( 3.80%) \u2588\n  5 pier\u015bcieni:     21 cz\u0105steczek ( 2.10%) \n  6 pier\u015bcieni:      3 cz\u0105steczek ( 0.30%) \n  7 pier\u015bcieni:      3 cz\u0105steczek ( 0.30%) \n\n\u2713 Z pier\u015bcieniami:    902 (90.2%)\n\u2713 Bez pier\u015bcieni:     98 (9.8%)\n\n\u2705 Zapisano: qm9_rings_analysis.png\n</pre> <pre>\n======================================================================\n\ud83d\udd04 ANALIZA ROTOWALNYCH WI\u0104ZA\u0143 (FLEXIBILITY)\n======================================================================\n\n\ud83d\udcca Statystyki rotowalnych wi\u0105za\u0144:\n  \u2022 \u015arednia:   0.89 wi\u0105za\u0144\n  \u2022 Mediana:   1 wi\u0105za\u0144\n  \u2022 Max:       5 wi\u0105za\u0144\n  \u2022 Std:       1.07\n\n\ud83d\udcc8 Rozk\u0142ad rotowalnych wi\u0105za\u0144:\n   0 wi\u0105za\u0144:    475 cz\u0105steczek (47.50%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n   1 wi\u0105za\u0144:    281 cz\u0105steczek (28.10%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n   2 wi\u0105za\u0144:    159 cz\u0105steczek (15.90%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\n   3 wi\u0105za\u0144:     55 cz\u0105steczek ( 5.50%) \u2588\u2588\n   4 wi\u0105za\u0144:     24 cz\u0105steczek ( 2.40%) \u2588\n\n\ud83d\udccb Klasyfikacja elastyczno\u015bci:\n  \u2022 Sztywne (0 wi\u0105za\u0144):        475 (47.5%)\n  \u2022 Semi-elastyczne (1-3):     495 (49.5%)\n  \u2022 Elastyczne (4+):           30 (3.0%)\n\n\u2705 Zapisano: qm9_rotatable_bonds.png\n</pre> <pre>\n======================================================================\n\ud83e\uddec ANALIZA FRAKCJI SP3 (SATURACJA)\n======================================================================\n\n======================================================================\n\ud83d\udd00 ANALIZA CHIRALNO\u015aCI\n======================================================================\nAnalizuj\u0119 centra chiralne...\n\n\ud83d\udcca Statystyki chiralno\u015bci:\n  \u2022 Cz\u0105steczki chiralne:    696 (69.6%)\n  \u2022 Cz\u0105steczki achiralne:   304 (30.4%)\n\n\ud83d\udcc8 Rozk\u0142ad liczby centr\u00f3w chiralnych:\n  0 centr\u00f3w:    304 cz\u0105steczek (30.40%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  1 centr\u00f3w:    184 cz\u0105steczek (18.40%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  2 centr\u00f3w:    203 cz\u0105steczek (20.30%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  3 centr\u00f3w:    133 cz\u0105steczek (13.30%) \u2588\u2588\u2588\u2588\u2588\u2588\n  4 centr\u00f3w:    111 cz\u0105steczek (11.10%) \u2588\u2588\u2588\u2588\u2588\n  5 centr\u00f3w:     44 cz\u0105steczek ( 4.40%) \u2588\u2588\n  6 centr\u00f3w:     17 cz\u0105steczek ( 1.70%) \n\n\u2705 Zapisano: qm9_chirality.png\n</pre> <pre>\n======================================================================\n\ud83d\udccb PODSUMOWANIE ANALIZY STRUKTURALNEJ\n======================================================================\n\n\ud83d\udd17 WI\u0104ZANIA:\n  \u2022 Single:     \u015arednio 7.50 wi\u0105za\u0144\n  \u2022 Double:     \u015arednio 0.61 wi\u0105za\u0144\n  \u2022 Triple:     \u015arednio 0.27 wi\u0105za\u0144\n  \u2022 Aromatic:   \u015arednio 0.97 wi\u0105za\u0144\n\n\u2b55 PIER\u015aCIENIE:\n  \u2022 \u015arednia liczba pier\u015bcieni:        1.70\n  \u2022 Moleku\u0142y z pier\u015bcieniami:          902 (90.2%)\n  \u2022 \u015arednia pier\u015bcieni aromatycznych:  0.19\n  \u2022 \u015arednia heterocykli:               1.02\n\n\ud83d\udd04 FLEXIBILITY:\n  \u2022 \u015arednia rotowalnych wi\u0105za\u0144:  0.89\n  \u2022 Moleku\u0142y sztywne (0):        475 (47.5%)\n  \u2022 Moleku\u0142y elastyczne (4+):    30 (3.0%)\n\n\ud83e\uddec NASYCENIE:\n  \u2022 \u015arednia frakcja sp\u00b3:         0.695\n  \u2022 Min frakcja sp\u00b3:             0.000\n  \u2022 Max frakcja sp\u00b3:             1.000\n\n\ud83d\udd00 CHIRALNO\u015a\u0106:\n  \u2022 Moleku\u0142y chiralne:           696 (69.6%)\n  \u2022 \u015arednia centr\u00f3w chiralnych:  1.78\n\n\u2705 CHARAKTERYSTYKA:\n  \u2022 QM9 zawiera g\u0142\u00f3wnie ma\u0142e, wzgl\u0119dnie sztywne moleku\u0142y\n  \u2022 Dominuj\u0105 struktury z 0-2 pier\u015bcieniami\n  \u2022 Mix moleku\u0142 aromatycznych i alifatycznych\n  \u2022 Niska chiralno\u015b\u0107 (typowe dla ma\u0142ych moleku\u0142)\n\n======================================================================\n\u2705 ANALIZA STRUKTURALNA ZAKO\u0143CZONA!\n======================================================================\n</pre> In\u00a0[26]: <pre># ============================================================\n# KOM\u00d3RKA 11: W\u0141A\u015aCIWO\u015aCI FIZYKOCHEMICZNE (RDKit)\n# ============================================================\n\nprint(\"=\"*70)\nprint(\"W\u0141A\u015aCIWO\u015aCI FIZYKOCHEMICZNE - QM9 DATASET\")\nprint(\"=\"*70)\n\n# ============================================================\n# 1. OBLICZANIE DESKRYPTOR\u00d3W RDKIT\n# ============================================================\n\nprint(\"\\n\u2697\ufe0f ETAP 1: OBLICZANIE DESKRYPTOR\u00d3W FIZYKOCHEMICZNYCH\")\nprint(\"-\" * 70)\n\nfrom rdkit import Chem\nfrom rdkit.Chem import Descriptors, Crippen, Lipinski\n\ndef calculate_physicochemical_properties(smiles):\n    \"\"\"Oblicza wszystkie kluczowe w\u0142a\u015bciwo\u015bci fizykochemiczne\"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        return None\n\n    try:\n        return {\n            'LogP': Crippen.MolLogP(mol),\n            'MolMR': Crippen.MolMR(mol),  # Molar Refractivity\n            'TPSA': Descriptors.TPSA(mol),\n            'HBD': Lipinski.NumHDonors(mol),  # H-Bond Donors\n            'HBA': Lipinski.NumHAcceptors(mol),  # H-Bond Acceptors\n            'LabuteASA': Descriptors.LabuteASA(mol),  # Surface Area\n            'BalabanJ': Descriptors.BalabanJ(mol),  # Topological index\n        }\n    except:\n        return None\n\nprint(\"Obliczam w\u0142a\u015bciwo\u015bci fizykochemiczne...\")\nprops_data = df['SMILES'].apply(calculate_physicochemical_properties)\ndf_props = props_data.apply(pd.Series)\n\n# Dodanie do g\u0142\u00f3wnego DataFrame\nfor col in df_props.columns:\n    df[col] = df_props[col]\n\nprint(f\"\\n\u2705 Obliczono {len(df_props.columns)} w\u0142a\u015bciwo\u015bci dla {len(df)} moleku\u0142\")\n\nprint(\"\\n\ud83d\udcca Statystyki w\u0142a\u015bciwo\u015bci fizykochemicznych:\")\nprint(df_props.describe())\n\n# ============================================================\n# 2. ANALIZA LogP (LIPOFILOWO\u015a\u0106)\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udca7 ANALIZA LogP (LIPOFILOWO\u015a\u0106)\")\nprint(\"=\"*70)\n\nprint(\"\\n\ud83d\udcca Statystyki LogP:\")\nprint(f\"  \u2022 \u015arednia:    {df['LogP'].mean():.3f}\")\nprint(f\"  \u2022 Mediana:    {df['LogP'].median():.3f}\")\nprint(f\"  \u2022 Std:        {df['LogP'].std():.3f}\")\nprint(f\"  \u2022 Min:        {df['LogP'].min():.3f}\")\nprint(f\"  \u2022 Max:        {df['LogP'].max():.3f}\")\n\n# Percentyle\nprint(\"\\n\ud83d\udcc8 Percentyle LogP:\")\nfor p in [10, 25, 50, 75, 90]:\n    val = df['LogP'].quantile(p/100)\n    print(f\"  \u2022 {p:2d}%:  {val:.3f}\")\n\n# Klasyfikacja lipofilowo\u015bci\nvery_hydrophilic = (df['LogP'] &lt; -1).sum()\nhydrophilic = ((df['LogP'] &gt;= -1) &amp; (df['LogP'] &lt; 1)).sum()\nmoderate = ((df['LogP'] &gt;= 1) &amp; (df['LogP'] &lt; 3)).sum()\nlipophilic = ((df['LogP'] &gt;= 3) &amp; (df['LogP'] &lt; 5)).sum()\nvery_lipophilic = (df['LogP'] &gt;= 5).sum()\n\nprint(f\"\\n\ud83d\udccb Klasyfikacja lipofilowo\u015bci:\")\nprint(f\"  \u2022 Bardzo hydrofilowe (LogP &lt; -1):    {very_hydrophilic:,} ({very_hydrophilic/len(df)*100:.1f}%)\")\nprint(f\"  \u2022 Hydrofilowe (-1 \u2264 LogP &lt; 1):       {hydrophilic:,} ({hydrophilic/len(df)*100:.1f}%)\")\nprint(f\"  \u2022 Umiarkowane (1 \u2264 LogP &lt; 3):        {moderate:,} ({moderate/len(df)*100:.1f}%)\")\nprint(f\"  \u2022 Lipofilowe (3 \u2264 LogP &lt; 5):         {lipophilic:,} ({lipophilic/len(df)*100:.1f}%)\")\nprint(f\"  \u2022 Bardzo lipofilowe (LogP \u2265 5):      {very_lipophilic:,} ({very_lipophilic/len(df)*100:.1f}%)\")\n\n# Outliers (IQR method)\nQ1 = df['LogP'].quantile(0.25)\nQ3 = df['LogP'].quantile(0.75)\nIQR = Q3 - Q1\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\noutliers_logp = df[(df['LogP'] &lt; lower_bound) | (df['LogP'] &gt; upper_bound)]\n\nprint(f\"\\n\u26a0\ufe0f  Outliers LogP (metoda IQR):\")\nprint(f\"  \u2022 Liczba outliers: {len(outliers_logp)} ({len(outliers_logp)/len(df)*100:.2f}%)\")\nprint(f\"  \u2022 Zakres normalny: [{lower_bound:.2f}, {upper_bound:.2f}]\")\n\n# Wizualizacja\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\n\n# 1. Histogram\naxes[0, 0].hist(df['LogP'], bins=60, color='dodgerblue', edgecolor='black', alpha=0.7)\naxes[0, 0].axvline(df['LogP'].mean(), color='red', linestyle='--', linewidth=2, \n                   label=f\"\u015arednia: {df['LogP'].mean():.2f}\")\naxes[0, 0].axvline(df['LogP'].median(), color='green', linestyle='--', linewidth=2,\n                   label=f\"Mediana: {df['LogP'].median():.2f}\")\naxes[0, 0].set_xlabel('LogP', fontsize=12, fontweight='bold')\naxes[0, 0].set_ylabel('Liczba moleku\u0142', fontsize=12, fontweight='bold')\naxes[0, 0].set_title('Rozk\u0142ad LogP', fontsize=13, fontweight='bold')\naxes[0, 0].legend()\naxes[0, 0].grid(axis='y', alpha=0.3)\n\n# 2. Boxplot z outliers\nbp = axes[0, 1].boxplot([df['LogP'].dropna()], labels=['LogP'], \n                        patch_artist=True, widths=0.5, showfliers=True)\nbp['boxes'][0].set_facecolor('lightblue')\naxes[0, 1].set_ylabel('LogP', fontsize=12, fontweight='bold')\naxes[0, 1].set_title('Boxplot LogP (z outliers)', fontsize=13, fontweight='bold')\naxes[0, 1].grid(axis='y', alpha=0.3)\n\n# 3. Klasyfikacja - barplot\ncategories = ['Bardzo\\nhydrofilowe', 'Hydrofilowe', 'Umiarkowane', \n              'Lipofilowe', 'Bardzo\\nlipofilowe']\nvalues = [very_hydrophilic, hydrophilic, moderate, lipophilic, very_lipophilic]\ncolors_logp = ['#3498db', '#5dade2', '#aed6f1', '#f8b739', '#e67e22']\n\nbars = axes[1, 0].bar(range(len(categories)), values, color=colors_logp, \n                      edgecolor='black', alpha=0.8, linewidth=1)\naxes[1, 0].set_xticks(range(len(categories)))\naxes[1, 0].set_xticklabels(categories, fontsize=9)\naxes[1, 0].set_ylabel('Liczba moleku\u0142', fontsize=12, fontweight='bold')\naxes[1, 0].set_title('Klasyfikacja lipofilowo\u015bci', fontsize=13, fontweight='bold')\naxes[1, 0].grid(axis='y', alpha=0.3)\n\nfor bar, val in zip(bars, values):\n    axes[1, 0].text(bar.get_x() + bar.get_width()/2, val + 10, \n                    f'{val}', ha='center', fontsize=9, fontweight='bold')\n\n# 4. LogP vs Masa molowa\naxes[1, 1].scatter(df['MolWt'], df['LogP'], alpha=0.3, s=10, color='darkblue')\naxes[1, 1].set_xlabel('Masa molowa (g/mol)', fontsize=12, fontweight='bold')\naxes[1, 1].set_ylabel('LogP', fontsize=12, fontweight='bold')\naxes[1, 1].set_title('LogP vs Masa molowa', fontsize=13, fontweight='bold')\naxes[1, 1].grid(alpha=0.3)\n\nplt.suptitle('Analiza lipofilowo\u015bci (LogP)', fontsize=16, fontweight='bold')\nplt.tight_layout()\nplt.savefig('qm9_logp_analysis.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_logp_analysis.png\")\nplt.show()\n\n# ============================================================\n# 3. ANALIZA TPSA (POLAR SURFACE AREA)\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83e\uddca ANALIZA TPSA (TOPOLOGICAL POLAR SURFACE AREA)\")\nprint(\"=\"*70)\n\nprint(\"\\n\ud83d\udcca Statystyki TPSA:\")\nprint(f\"  \u2022 \u015arednia:    {df['TPSA'].mean():.2f} \u0172\")\nprint(f\"  \u2022 Mediana:    {df['TPSA'].median():.2f} \u0172\")\nprint(f\"  \u2022 Std:        {df['TPSA'].std():.2f} \u0172\")\nprint(f\"  \u2022 Max:        {df['TPSA'].max():.2f} \u0172\")\n\n# Drug-likeness wed\u0142ug TPSA\n# TPSA &lt; 140 \u0172 - dobra przepuszczalno\u015b\u0107 BBB (blood-brain barrier)\n# TPSA &lt; 90 \u0172 - optymalna dla lek\u00f3w CNS\nbbb_permeable = (df['TPSA'] &lt; 140).sum()\ncns_optimal = (df['TPSA'] &lt; 90).sum()\n\nprint(f\"\\n\ud83d\udc8a Drug-likeness (TPSA):\")\nprint(f\"  \u2022 BBB permeable (&lt; 140 \u0172):    {bbb_permeable:,} ({bbb_permeable/len(df)*100:.1f}%)\")\nprint(f\"  \u2022 CNS optimal (&lt; 90 \u0172):       {cns_optimal:,} ({cns_optimal/len(df)*100:.1f}%)\")\n\n# Wizualizacja\nfig, axes = plt.subplots(1, 3, figsize=(18, 5))\n\n# 1. Histogram\naxes[0].hist(df['TPSA'], bins=50, color='coral', edgecolor='black', alpha=0.7)\naxes[0].axvline(90, color='green', linestyle='--', linewidth=2, label='CNS optimal (90)')\naxes[0].axvline(140, color='orange', linestyle='--', linewidth=2, label='BBB limit (140)')\naxes[0].set_xlabel('TPSA (\u0172)', fontsize=12, fontweight='bold')\naxes[0].set_ylabel('Liczba moleku\u0142', fontsize=12, fontweight='bold')\naxes[0].set_title('Rozk\u0142ad TPSA', fontsize=13, fontweight='bold')\naxes[0].legend()\naxes[0].grid(axis='y', alpha=0.3)\n\n# 2. TPSA vs LogP\naxes[1].scatter(df['LogP'], df['TPSA'], alpha=0.3, s=10, color='purple')\naxes[1].set_xlabel('LogP', fontsize=12, fontweight='bold')\naxes[1].set_ylabel('TPSA (\u0172)', fontsize=12, fontweight='bold')\naxes[1].set_title('TPSA vs LogP', fontsize=13, fontweight='bold')\naxes[1].grid(alpha=0.3)\n\n# 3. Pie chart - drug-likeness\ncategories_tpsa = ['CNS optimal\\n(&lt;90)', 'BBB permeable\\n(90-140)', 'High TPSA\\n(&gt;140)']\nvalues_tpsa = [cns_optimal, bbb_permeable - cns_optimal, len(df) - bbb_permeable]\ncolors_tpsa = ['#2ecc71', '#f39c12', '#e74c3c']\n\naxes[2].pie(values_tpsa, labels=categories_tpsa, autopct='%1.1f%%',\n            colors=colors_tpsa, startangle=90, \n            textprops={'fontsize': 11, 'fontweight': 'bold'})\naxes[2].set_title('TPSA Drug-likeness', fontsize=13, fontweight='bold')\n\nplt.tight_layout()\nplt.savefig('qm9_tpsa_analysis.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_tpsa_analysis.png\")\nplt.show()\n\n# ============================================================\n# 4. WI\u0104ZANIA WODOROWE (HBD/HBA)\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udd17 ANALIZA WI\u0104ZA\u0143 WODOROWYCH (HBD/HBA)\")\nprint(\"=\"*70)\n\nprint(\"\\n\ud83d\udcca Statystyki:\")\nprint(f\"  \u2022 \u015arednia HBD (donory):     {df['HBD'].mean():.2f}\")\nprint(f\"  \u2022 \u015arednia HBA (akceptory):  {df['HBA'].mean():.2f}\")\nprint(f\"  \u2022 Max HBD:                  {df['HBD'].max():.0f}\")\nprint(f\"  \u2022 Max HBA:                  {df['HBA'].max():.0f}\")\n\n# Rozk\u0142ad\nprint(\"\\n\ud83d\udcc8 Rozk\u0142ad HBD:\")\nhbd_dist = df['HBD'].value_counts().sort_index()\nfor count, freq in hbd_dist.items():\n    pct = (freq / len(df)) * 100\n    if pct &gt; 1:\n        bar = '\u2588' * int(pct / 3)\n        print(f\"  {count:.0f} donor\u00f3w: {freq:5,} ({pct:5.2f}%) {bar}\")\n\nprint(\"\\n\ud83d\udcc8 Rozk\u0142ad HBA:\")\nhba_dist = df['HBA'].value_counts().sort_index()\nfor count, freq in hba_dist.items():\n    pct = (freq / len(df)) * 100\n    if pct &gt; 1:\n        bar = '\u2588' * int(pct / 3)\n        print(f\"  {count:.0f} akceptor\u00f3w: {freq:5,} ({pct:5.2f}%) {bar}\")\n\n# Wizualizacja\nfig, axes = plt.subplots(1, 3, figsize=(18, 5))\n\n# 1. HBD histogram\naxes[0].bar(hbd_dist.index, hbd_dist.values, color='#3498db', \n            edgecolor='black', alpha=0.8, linewidth=1)\naxes[0].set_xlabel('Liczba donor\u00f3w H (HBD)', fontsize=12, fontweight='bold')\naxes[0].set_ylabel('Liczba moleku\u0142', fontsize=12, fontweight='bold')\naxes[0].set_title('Rozk\u0142ad donor\u00f3w wodoru', fontsize=13, fontweight='bold')\naxes[0].grid(axis='y', alpha=0.3)\n\n# 2. HBA histogram\naxes[1].bar(hba_dist.index, hba_dist.values, color='#e74c3c', \n            edgecolor='black', alpha=0.8, linewidth=1)\naxes[1].set_xlabel('Liczba akceptor\u00f3w H (HBA)', fontsize=12, fontweight='bold')\naxes[1].set_ylabel('Liczba moleku\u0142', fontsize=12, fontweight='bold')\naxes[1].set_title('Rozk\u0142ad akceptor\u00f3w wodoru', fontsize=13, fontweight='bold')\naxes[1].grid(axis='y', alpha=0.3)\n\n# 3. HBD vs HBA scatter\naxes[2].scatter(df['HBD'], df['HBA'], alpha=0.4, s=15, color='green', edgecolors='black', linewidth=0.3)\naxes[2].set_xlabel('HBD (donory)', fontsize=12, fontweight='bold')\naxes[2].set_ylabel('HBA (akceptory)', fontsize=12, fontweight='bold')\naxes[2].set_title('HBD vs HBA', fontsize=13, fontweight='bold')\naxes[2].grid(alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('qm9_hbond_analysis.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_hbond_analysis.png\")\nplt.show()\n\n# ============================================================\n# 5. REGU\u0141A LIPI\u0143SKIEGO (RULE OF 5)\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udc8a REGU\u0141A LIPI\u0143SKIEGO (RULE OF 5)\")\nprint(\"=\"*70)\n\n# Kryteria Lipi\u0144skiego:\n# 1. Masa molowa \u2264 500 Da\n# 2. LogP \u2264 5\n# 3. HBD \u2264 5\n# 4. HBA \u2264 10\n\ndf['Lipinski_MW'] = df['MolWt'] &lt;= 500\ndf['Lipinski_LogP'] = df['LogP'] &lt;= 5\ndf['Lipinski_HBD'] = df['HBD'] &lt;= 5\ndf['Lipinski_HBA'] = df['HBA'] &lt;= 10\n\ndf['Lipinski_violations'] = (~df['Lipinski_MW']).astype(int) + \\\n                             (~df['Lipinski_LogP']).astype(int) + \\\n                             (~df['Lipinski_HBD']).astype(int) + \\\n                             (~df['Lipinski_HBA']).astype(int)\n\ndf['Lipinski_compliant'] = df['Lipinski_violations'] &lt;= 1  # 0 lub 1 naruszenie = OK\n\n# Statystyki\ncompliant = df['Lipinski_compliant'].sum()\nnon_compliant = (~df['Lipinski_compliant']).sum()\n\nprint(f\"\\n\ud83d\udcca Zgodno\u015b\u0107 z regu\u0142\u0105 Lipi\u0144skiego:\")\nprint(f\"  \u2022 Zgodne (\u22641 naruszenie):    {compliant:,} ({compliant/len(df)*100:.1f}%)\")\nprint(f\"  \u2022 Niezgodne (&gt;1 naruszenie): {non_compliant:,} ({non_compliant/len(df)*100:.1f}%)\")\n\nprint(f\"\\n\ud83d\udcc8 Rozk\u0142ad narusze\u0144:\")\nviolations_dist = df['Lipinski_violations'].value_counts().sort_index()\nfor count, freq in violations_dist.items():\n    pct = (freq / len(df)) * 100\n    bar = '\u2588' * int(pct / 2)\n    print(f\"  {count:.0f} narusze\u0144: {freq:5,} ({pct:5.2f}%) {bar}\")\n\nprint(f\"\\n\ud83d\udccb Szczeg\u00f3\u0142owe naruszenia:\")\nprint(f\"  \u2022 MW &gt; 500:    {(~df['Lipinski_MW']).sum():,}\")\nprint(f\"  \u2022 LogP &gt; 5:    {(~df['Lipinski_LogP']).sum():,}\")\nprint(f\"  \u2022 HBD &gt; 5:     {(~df['Lipinski_HBD']).sum():,}\")\nprint(f\"  \u2022 HBA &gt; 10:    {(~df['Lipinski_HBA']).sum():,}\")\n\n# Wizualizacja\nfig, axes = plt.subplots(1, 3, figsize=(18, 5))\n\n# 1. Pie chart - compliance\naxes[0].pie([compliant, non_compliant],\n            labels=['Zgodne\\n(Ro5)', 'Niezgodne'],\n            autopct='%1.1f%%', colors=['#2ecc71', '#e74c3c'],\n            startangle=90, textprops={'fontsize': 12, 'fontweight': 'bold'})\naxes[0].set_title('Zgodno\u015b\u0107 z regu\u0142\u0105 Lipi\u0144skiego', fontsize=13, fontweight='bold')\n\n# 2. Barplot narusze\u0144\naxes[1].bar(violations_dist.index, violations_dist.values, color='#9b59b6', \n            edgecolor='black', alpha=0.8, linewidth=1)\naxes[1].set_xlabel('Liczba narusze\u0144 Ro5', fontsize=12, fontweight='bold')\naxes[1].set_ylabel('Liczba moleku\u0142', fontsize=12, fontweight='bold')\naxes[1].set_title('Rozk\u0142ad narusze\u0144 Ro5', fontsize=13, fontweight='bold')\naxes[1].grid(axis='y', alpha=0.3)\n\n# 3. Szczeg\u00f3\u0142owe naruszenia\nviolation_types = ['MW &gt; 500', 'LogP &gt; 5', 'HBD &gt; 5', 'HBA &gt; 10']\nviolation_counts = [\n    (~df['Lipinski_MW']).sum(),\n    (~df['Lipinski_LogP']).sum(),\n    (~df['Lipinski_HBD']).sum(),\n    (~df['Lipinski_HBA']).sum()\n]\n\naxes[2].barh(range(len(violation_types)), violation_counts, color='#e74c3c', \n             edgecolor='black', alpha=0.8, linewidth=1)\naxes[2].set_yticks(range(len(violation_types)))\naxes[2].set_yticklabels(violation_types)\naxes[2].set_xlabel('Liczba moleku\u0142', fontsize=12, fontweight='bold')\naxes[2].set_title('Typy narusze\u0144 Ro5', fontsize=13, fontweight='bold')\naxes[2].grid(axis='x', alpha=0.3)\n\nfor i, val in enumerate(violation_counts):\n    axes[2].text(val + 5, i, f'{val}', va='center', fontweight='bold')\n\nplt.tight_layout()\nplt.savefig('qm9_lipinski_ro5.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_lipinski_ro5.png\")\nplt.show()\n\n# ============================================================\n# 6. KORELACJE MI\u0118DZY DESKRYPTORAMI\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udd17 KORELACJE MI\u0118DZY DESKRYPTORAMI\")\nprint(\"=\"*70)\n\n# Wyb\u00f3r deskryptor\u00f3w do analizy\ndescriptors_to_correlate = ['MolWt', 'LogP', 'TPSA', 'HBD', 'HBA', 'MolMR', \n                            'HeavyAtoms', 'rotatable_bonds', 'frac_csp3']\n\ndf_corr = df[descriptors_to_correlate].copy()\n\n# Macierz korelacji\ncorr_matrix = df_corr.corr()\n\nprint(\"\\n\ud83d\udcca Najsilniejsze korelacje:\")\n# Ekstakcja korelacji (bez diagonali)\ncorrelations_list = []\nfor i in range(len(corr_matrix.columns)):\n    for j in range(i+1, len(corr_matrix.columns)):\n        correlations_list.append({\n            'Prop1': corr_matrix.columns[i],\n            'Prop2': corr_matrix.columns[j],\n            'Correlation': corr_matrix.iloc[i, j]\n        })\n\ndf_corr_list = pd.DataFrame(correlations_list)\ndf_corr_list = df_corr_list.sort_values('Correlation', key=abs, ascending=False)\n\nprint(\"\\nTop 10 najsilniejszych korelacji:\")\nfor idx, row in df_corr_list.head(10).iterrows():\n    print(f\"  {row['Prop1']:20s} \u2194 {row['Prop2']:20s}  r = {row['Correlation']:+.3f}\")\n\n# Wizualizacja\nfig, axes = plt.subplots(1, 2, figsize=(16, 6))\n\n# 1. Heatmap\nimport seaborn as sns\nsns.heatmap(corr_matrix, annot=True, fmt='.2f', cmap='RdBu_r', \n            center=0, square=True, linewidths=0.5, cbar_kws={\"shrink\": 0.8},\n            vmin=-1, vmax=1, ax=axes[0])\naxes[0].set_title('Macierz korelacji deskryptor\u00f3w', fontsize=13, fontweight='bold')\n\n# 2. Top korelacje - barplot\ntop10 = df_corr_list.head(10).copy()\ntop10['Pair'] = top10['Prop1'] + ' \u2194\\n' + top10['Prop2']\ncolors_corr = ['#d73027' if x &lt; 0 else '#4575b4' for x in top10['Correlation']]\n\naxes[1].barh(range(len(top10)), top10['Correlation'], color=colors_corr, \n             edgecolor='black', alpha=0.8, linewidth=0.7)\naxes[1].set_yticks(range(len(top10)))\naxes[1].set_yticklabels(top10['Pair'], fontsize=8)\naxes[1].set_xlabel('Wsp\u00f3\u0142czynnik korelacji', fontsize=12, fontweight='bold')\naxes[1].set_title('Top 10 najsilniejszych korelacji', fontsize=13, fontweight='bold')\naxes[1].axvline(0, color='black', linewidth=0.8)\naxes[1].grid(axis='x', alpha=0.3)\naxes[1].invert_yaxis()\n\nfor i, val in enumerate(top10['Correlation']):\n    axes[1].text(val + 0.02 if val &gt; 0 else val - 0.02, i, \n                 f'{val:.2f}', va='center', ha='left' if val &gt; 0 else 'right',\n                 fontweight='bold', fontsize=8)\n\nplt.tight_layout()\nplt.savefig('qm9_descriptors_correlation.png', dpi=300, bbox_inches='tight')\nprint(\"\\n\u2705 Zapisano: qm9_descriptors_correlation.png\")\nplt.show()\n\n# ============================================================\n# 7. PODSUMOWANIE\n# ============================================================\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"\ud83d\udccb PODSUMOWANIE W\u0141A\u015aCIWO\u015aCI FIZYKOCHEMICZNYCH\")\nprint(\"=\"*70)\n\nprint(f\"\"\"\n\ud83d\udca7 LIPOFILOWO\u015a\u0106 (LogP):\n  \u2022 \u015arednia:              {df['LogP'].mean():.3f}\n  \u2022 Zakres:               {df['LogP'].min():.2f} - {df['LogP'].max():.2f}\n  \u2022 Hydrofilowe (&lt;1):     {(df['LogP'] &lt; 1).sum():,} ({(df['LogP'] &lt; 1).sum()/len(df)*100:.1f}%)\n  \u2022 Lipofilowe (\u22653):      {(df['LogP'] &gt;= 3).sum():,} ({(df['LogP'] &gt;= 3).sum()/len(df)*100:.1f}%)\n\n\ud83e\uddca TPSA (Polar Surface Area):\n  \u2022 \u015arednia:              {df['TPSA'].mean():.2f} \u0172\n  \u2022 BBB permeable:        {bbb_permeable:,} ({bbb_permeable/len(df)*100:.1f}%)\n  \u2022 CNS optimal:          {cns_optimal:,} ({cns_optimal/len(df)*100:.1f}%)\n\n\ud83d\udd17 WI\u0104ZANIA WODOROWE:\n  \u2022 \u015arednia HBD:          {df['HBD'].mean():.2f}\n  \u2022 \u015arednia HBA:          {df['HBA'].mean():.2f}\n  \u2022 Max HBD:              {df['HBD'].max():.0f}\n  \u2022 Max HBA:              {df['HBA'].max():.0f}\n\n\ud83d\udc8a REGU\u0141A LIPI\u0143SKIEGO (Ro5):\n  \u2022 Zgodne moleku\u0142y:      {compliant:,} ({compliant/len(df)*100:.1f}%)\n  \u2022 0 narusze\u0144:           {(df['Lipinski_violations']==0).sum():,}\n  \u2022 1 naruszenie:         {(df['Lipinski_violations']==1).sum():,}\n  \u2022 &gt;1 narusze\u0144:          {(df['Lipinski_violations']&gt;1).sum():,}\n\n\ud83d\udd17 KORELACJE:\n  \u2022 Najsilniejsza:        {df_corr_list.iloc[0]['Prop1']} \u2194 {df_corr_list.iloc[0]['Prop2']} (r={df_corr_list.iloc[0]['Correlation']:.3f})\n  \u2022 Silne korelacje (|r|&gt;0.7): {(df_corr_list['Correlation'].abs() &gt; 0.7).sum()}\n\n\u2705 WNIOSKI:\n  \u2022 QM9 zawiera g\u0142\u00f3wnie ma\u0142e, relatywnie hydrofilowe moleku\u0142y\n  \u2022 Wysoka zgodno\u015b\u0107 z regu\u0142\u0105 Lipi\u0144skiego ({compliant/len(df)*100:.0f}%)\n  \u2022 Niska TPSA \u2192 dobra przepuszczalno\u015b\u0107 b\u0142on\n  \u2022 Deskryptory silnie skorelowane z mas\u0105 molow\u0105\n\"\"\")\n\nprint(\"=\"*70)\nprint(\"\u2705 ANALIZA W\u0141A\u015aCIWO\u015aCI FIZYKOCHEMICZNYCH ZAKO\u0143CZONA!\")\nprint(\"=\"*70)\n</pre> <pre>======================================================================\nW\u0141A\u015aCIWO\u015aCI FIZYKOCHEMICZNE - QM9 DATASET\n======================================================================\n\n\u2697\ufe0f ETAP 1: OBLICZANIE DESKRYPTOR\u00d3W FIZYKOCHEMICZNYCH\n----------------------------------------------------------------------\nObliczam w\u0142a\u015bciwo\u015bci fizykochemiczne...\n\n\u2705 Obliczono 7 w\u0142a\u015bciwo\u015bci dla 1000 moleku\u0142\n\n\ud83d\udcca Statystyki w\u0142a\u015bciwo\u015bci fizykochemicznych:\n              LogP        MolMR         TPSA          HBD          HBA  \\\ncount  1000.000000  1000.000000  1000.000000  1000.000000  1000.000000   \nmean      0.104381    31.821830    37.802210     0.972000     2.053000   \nstd       1.173836     3.606108    21.399043     0.889948     1.093337   \nmin      -3.467400    14.868400     0.000000     0.000000     0.000000   \n25%      -0.660365    29.675525    21.510000     0.000000     1.000000   \n50%       0.158600    31.994000    36.510000     1.000000     2.000000   \n75%       0.923925    34.185250    52.512500     2.000000     3.000000   \nmax       3.222700    41.365000   112.360000     4.000000     5.000000   \n\n         LabuteASA     BalabanJ  \ncount  1000.000000  1000.000000  \nmean     52.579936     2.448441  \nstd       3.722869     0.525115  \nmin      24.605606     0.000000  \n25%      51.782555     2.071725  \n50%      53.587200     2.269522  \n75%      54.820772     2.693324  \nmax      58.088080     4.837063  \n\n======================================================================\n\ud83d\udca7 ANALIZA LogP (LIPOFILOWO\u015a\u0106)\n======================================================================\n\n\ud83d\udcca Statystyki LogP:\n  \u2022 \u015arednia:    0.104\n  \u2022 Mediana:    0.159\n  \u2022 Std:        1.174\n  \u2022 Min:        -3.467\n  \u2022 Max:        3.223\n\n\ud83d\udcc8 Percentyle LogP:\n  \u2022 10%:  -1.387\n  \u2022 25%:  -0.660\n  \u2022 50%:  0.159\n  \u2022 75%:  0.924\n  \u2022 90%:  1.561\n\n\ud83d\udccb Klasyfikacja lipofilowo\u015bci:\n  \u2022 Bardzo hydrofilowe (LogP &lt; -1):    179 (17.9%)\n  \u2022 Hydrofilowe (-1 \u2264 LogP &lt; 1):       592 (59.2%)\n  \u2022 Umiarkowane (1 \u2264 LogP &lt; 3):        227 (22.7%)\n  \u2022 Lipofilowe (3 \u2264 LogP &lt; 5):         2 (0.2%)\n  \u2022 Bardzo lipofilowe (LogP \u2265 5):      0 (0.0%)\n\n\u26a0\ufe0f  Outliers LogP (metoda IQR):\n  \u2022 Liczba outliers: 7 (0.70%)\n  \u2022 Zakres normalny: [-3.04, 3.30]\n</pre> <pre>C:\\Users\\slast\\AppData\\Local\\Temp\\ipykernel_6436\\1039049785.py:114: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  bp = axes[0, 1].boxplot([df['LogP'].dropna()], labels=['LogP'],\n</pre> <pre>\n\u2705 Zapisano: qm9_logp_analysis.png\n</pre> <pre>\n======================================================================\n\ud83e\uddca ANALIZA TPSA (TOPOLOGICAL POLAR SURFACE AREA)\n======================================================================\n\n\ud83d\udcca Statystyki TPSA:\n  \u2022 \u015arednia:    37.80 \u0172\n  \u2022 Mediana:    36.51 \u0172\n  \u2022 Std:        21.40 \u0172\n  \u2022 Max:        112.36 \u0172\n\n\ud83d\udc8a Drug-likeness (TPSA):\n  \u2022 BBB permeable (&lt; 140 \u0172):    1,000 (100.0%)\n  \u2022 CNS optimal (&lt; 90 \u0172):       991 (99.1%)\n\n\u2705 Zapisano: qm9_tpsa_analysis.png\n</pre> <pre>\n======================================================================\n\ud83d\udd17 ANALIZA WI\u0104ZA\u0143 WODOROWYCH (HBD/HBA)\n======================================================================\n\n\ud83d\udcca Statystyki:\n  \u2022 \u015arednia HBD (donory):     0.97\n  \u2022 \u015arednia HBA (akceptory):  2.05\n  \u2022 Max HBD:                  4\n  \u2022 Max HBA:                  5\n\n\ud83d\udcc8 Rozk\u0142ad HBD:\n  0 donor\u00f3w:   348 (34.80%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  1 donor\u00f3w:   392 (39.20%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  2 donor\u00f3w:   202 (20.20%) \u2588\u2588\u2588\u2588\u2588\u2588\n  3 donor\u00f3w:    56 ( 5.60%) \u2588\n\n\ud83d\udcc8 Rozk\u0142ad HBA:\n  0 akceptor\u00f3w:    66 ( 6.60%) \u2588\u2588\n  1 akceptor\u00f3w:   249 (24.90%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  2 akceptor\u00f3w:   355 (35.50%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  3 akceptor\u00f3w:   247 (24.70%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n  4 akceptor\u00f3w:    62 ( 6.20%) \u2588\u2588\n  5 akceptor\u00f3w:    21 ( 2.10%) \n\n\u2705 Zapisano: qm9_hbond_analysis.png\n</pre> <pre>\n======================================================================\n\ud83d\udc8a REGU\u0141A LIPI\u0143SKIEGO (RULE OF 5)\n======================================================================\n\n\ud83d\udcca Zgodno\u015b\u0107 z regu\u0142\u0105 Lipi\u0144skiego:\n  \u2022 Zgodne (\u22641 naruszenie):    1,000 (100.0%)\n  \u2022 Niezgodne (&gt;1 naruszenie): 0 (0.0%)\n\n\ud83d\udcc8 Rozk\u0142ad narusze\u0144:\n  0 narusze\u0144: 1,000 (100.00%) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n\n\ud83d\udccb Szczeg\u00f3\u0142owe naruszenia:\n  \u2022 MW &gt; 500:    0\n  \u2022 LogP &gt; 5:    0\n  \u2022 HBD &gt; 5:     0\n  \u2022 HBA &gt; 10:    0\n</pre> <pre>C:\\Users\\slast\\AppData\\Local\\Temp\\ipykernel_6436\\1039049785.py:358: UserWarning: Tight layout not applied. The left and right margins cannot be made large enough to accommodate all Axes decorations.\n  plt.tight_layout()\n</pre> <pre>\n\u2705 Zapisano: qm9_lipinski_ro5.png\n</pre> <pre>\n======================================================================\n\ud83d\udd17 KORELACJE MI\u0118DZY DESKRYPTORAMI\n======================================================================\n\n\ud83d\udcca Najsilniejsze korelacje:\n\nTop 10 najsilniejszych korelacji:\n  MolWt                \u2194 HeavyAtoms            r = +0.927\n  TPSA                 \u2194 HBA                   r = +0.821\n  LogP                 \u2194 HBD                   r = -0.638\n  MolMR                \u2194 HeavyAtoms            r = +0.578\n  TPSA                 \u2194 HBD                   r = +0.572\n  LogP                 \u2194 MolMR                 r = +0.495\n  LogP                 \u2194 TPSA                  r = -0.476\n  MolWt                \u2194 MolMR                 r = +0.470\n  HBA                  \u2194 MolMR                 r = -0.462\n  TPSA                 \u2194 frac_csp3             r = -0.447\n\n\u2705 Zapisano: qm9_descriptors_correlation.png\n</pre> <pre>\n======================================================================\n\ud83d\udccb PODSUMOWANIE W\u0141A\u015aCIWO\u015aCI FIZYKOCHEMICZNYCH\n======================================================================\n\n\ud83d\udca7 LIPOFILOWO\u015a\u0106 (LogP):\n  \u2022 \u015arednia:              0.104\n  \u2022 Zakres:               -3.47 - 3.22\n  \u2022 Hydrofilowe (&lt;1):     771 (77.1%)\n  \u2022 Lipofilowe (\u22653):      2 (0.2%)\n\n\ud83e\uddca TPSA (Polar Surface Area):\n  \u2022 \u015arednia:              37.80 \u0172\n  \u2022 BBB permeable:        1,000 (100.0%)\n  \u2022 CNS optimal:          991 (99.1%)\n\n\ud83d\udd17 WI\u0104ZANIA WODOROWE:\n  \u2022 \u015arednia HBD:          0.97\n  \u2022 \u015arednia HBA:          2.05\n  \u2022 Max HBD:              4\n  \u2022 Max HBA:              5\n\n\ud83d\udc8a REGU\u0141A LIPI\u0143SKIEGO (Ro5):\n  \u2022 Zgodne moleku\u0142y:      1,000 (100.0%)\n  \u2022 0 narusze\u0144:           1,000\n  \u2022 1 naruszenie:         0\n  \u2022 &gt;1 narusze\u0144:          0\n\n\ud83d\udd17 KORELACJE:\n  \u2022 Najsilniejsza:        MolWt \u2194 HeavyAtoms (r=0.927)\n  \u2022 Silne korelacje (|r|&gt;0.7): 2\n\n\u2705 WNIOSKI:\n  \u2022 QM9 zawiera g\u0142\u00f3wnie ma\u0142e, relatywnie hydrofilowe moleku\u0142y\n  \u2022 Wysoka zgodno\u015b\u0107 z regu\u0142\u0105 Lipi\u0144skiego (100%)\n  \u2022 Niska TPSA \u2192 dobra przepuszczalno\u015b\u0107 b\u0142on\n  \u2022 Deskryptory silnie skorelowane z mas\u0105 molow\u0105\n\n======================================================================\n\u2705 ANALIZA W\u0141A\u015aCIWO\u015aCI FIZYKOCHEMICZNYCH ZAKO\u0143CZONA!\n======================================================================\n</pre>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%A7%AA-Historia-powstania-zbioru-danych-QM9","title":"\ud83e\uddea Historia powstania zbioru danych QM9\u00b6","text":"<p>Zbi\u00f3r danych QM9 jest jednym z najwa\u017cniejszych i najcz\u0119\u015bciej wykorzystywanych benchmark\u00f3w w chemoinformatyce, uczeniu maszynowym dla chemii oraz projektowaniu cz\u0105steczek. Jego stworzenie by\u0142o odpowiedzi\u0105 na potrzeb\u0119 posiadania du\u017cego, jednorodnego i wysokiej jako\u015bci zbioru danych kwantowo-chemicznych, kt\u00f3ry umo\u017cliwi\u0142by rozw\u00f3j algorytm\u00f3w ML w obszarze w\u0142a\u015bciwo\u015bci moleku\u0142.</p>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%93%9C-Geneza-projektu","title":"\ud83d\udcdc Geneza projektu\u00b6","text":"<p>Zbi\u00f3r QM9 zosta\u0142 opracowany w latach 2014\u20132017 przez zesp\u00f3\u0142 naukowc\u00f3w z University of Basel, Cornell University i University of Vienna: Ramakrishnan, Dral, Rupp i von Lilienfeld. Zosta\u0142 po raz pierwszy opisany w publikacji:</p> <p>\u201cQuantum chemistry structures and properties of 134 kilo molecules\u201d (Scientific Data, 2014)</p> <p>Celem autor\u00f3w by\u0142o stworzenie systematycznego i kompletnego zbioru obejmuj\u0105cego tysi\u0105ce ma\u0142ych cz\u0105steczek organicznych oraz ich w\u0142a\u015bciwo\u015bci obliczonych metodami chemii kwantowej.</p>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%A7%A9-Jak-powsta%C5%82-zbi%C3%B3r?","title":"\ud83e\udde9 Jak powsta\u0142 zbi\u00f3r?\u00b6","text":"<p>Proces tworzenia QM9 obejmowa\u0142 kilka etap\u00f3w:</p>"},{"location":"02_eda_chem/EDA_QM9/#1.-Wyb%C3%B3r-cz%C4%85steczek-(enumeracja-strukturalna)","title":"1. Wyb\u00f3r cz\u0105steczek (enumeracja strukturalna)\u00b6","text":"<p>Autorzy wybrali wszystkie stabilne cz\u0105steczki organiczne o wzorze sumarycznym zawieraj\u0105cym tylko:</p> <ul> <li>C,</li> <li>H,</li> <li>O,</li> <li>N,</li> <li>F, oraz maksymalnie 9 atom\u00f3w ci\u0119\u017ckich. Dlatego nazwa datasetu to QM9.</li> </ul> <p>\ud83d\udccc W sumie zebrano 133 885 struktur.</p>"},{"location":"02_eda_chem/EDA_QM9/#2.-Optymalizacja-geometrii","title":"2. Optymalizacja geometrii\u00b6","text":"<p>Dla ka\u017cdej cz\u0105steczki wykonano obliczenia metod\u0105 DFT (Density Functional Theory) z funkcjona\u0142em:</p> <ul> <li>B3LYP</li> <li>baz\u0105 6-31G(2df,p)</li> </ul> <p>By\u0142a to ogromna kampania obliczeniowa \u2014 w sumie miliony iteracji oblicze\u0144 kwantowych.</p>"},{"location":"02_eda_chem/EDA_QM9/#3.-Wyznaczenie-w%C5%82a%C5%9Bciwo%C5%9Bci-fizykochemicznych","title":"3. Wyznaczenie w\u0142a\u015bciwo\u015bci fizykochemicznych\u00b6","text":"<p>Dla ka\u017cdej cz\u0105steczki obliczono \u2265 17 w\u0142a\u015bciwo\u015bci, m.in.:</p> <ul> <li>energie atomizacji,</li> <li>moment dipolowy,</li> <li>HOMO, LUMO, gap,</li> <li>cz\u0119stotliwo\u015bci drga\u0144,</li> <li>polaryzowalno\u015b\u0107,</li> <li>mas\u0119,</li> <li>geometri\u0119 3D,</li> <li>temperatur\u0119 wrzenia (przybli\u017con\u0105 metodami kwantowymi).</li> </ul> <p>\ud83d\udcca Dzi\u0119ki temu zbi\u00f3r jest idealny do regresji, predykcji w\u0142a\u015bciwo\u015bci i zada\u0144 ML w chemii.</p>"},{"location":"02_eda_chem/EDA_QM9/#4.-Standaryzacja-i-walidacja","title":"4. Standaryzacja i walidacja\u00b6","text":"<p>Ka\u017cd\u0105 struktur\u0119 zweryfikowano:</p> <ul> <li>poprawno\u015b\u0107 SMILES,</li> <li>poprawno\u015b\u0107 minimalnej energii,</li> <li>brak fragmentacji,</li> <li>poprawna topologia.</li> </ul> <p>Wczesne wersje datasetu zawiera\u0142y ~300 b\u0142\u0119dnych geometrii \u2014 zosta\u0142y p\u00f3\u017aniej usuni\u0119te.</p>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%9A%80-Znaczenie-QM9-dla-wsp%C3%B3%C5%82czesnego-ML-w-chemii","title":"\ud83d\ude80 Znaczenie QM9 dla wsp\u00f3\u0142czesnego ML w chemii\u00b6","text":"<p>Zbi\u00f3r QM9 sta\u0142 si\u0119 z\u0142otym standardem w testowaniu modeli:</p> <ul> <li>GNN (Graph Neural Networks),</li> <li>Message Passing Neural Networks,</li> <li>SchNet, PhysNet, DimeNet,</li> <li>Transformer\u00f3w molekularnych,</li> <li>modeli generatywnych (VAE, diffusion models).</li> </ul> <p>Poniewa\u017c dane s\u0105 jednorodne, czyste i precyzyjne, QM9 pozwala por\u00f3wnywa\u0107 algorytmy w spos\u00f3b uczciwy i powtarzalny.</p>"},{"location":"02_eda_chem/EDA_QM9/#%E2%AD%90-Dlaczego-QM9-jest-tak-wa%C5%BCny?","title":"\u2b50 Dlaczego QM9 jest tak wa\u017cny?\u00b6","text":"<ul> <li>zawiera najwi\u0119kszy do tamtej pory publiczny zbi\u00f3r oblicze\u0144 DFT,</li> <li>jest kompletny w zakresie ma\u0142ych cz\u0105steczek organicznych,</li> <li>ma wysok\u0105 jako\u015b\u0107,</li> <li>idealnie nadaje si\u0119 do projekt\u00f3w ML w chemii \u2764\ufe0f\u200d\ud83d\udd25.</li> </ul> <p>Dzi\u015b stanowi fundament ogromnej cz\u0119\u015bci bada\u0144 nad AI for Molecules.</p>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%93%82-Opis-zbioru-danych-QM9","title":"\ud83d\udcc2 Opis zbioru danych QM9\u00b6","text":"<p>W tej sekcji przedstawiono szczeg\u00f3\u0142owy opis struktur danych dost\u0119pnych w roboczej wersji zbioru QM9, zawieraj\u0105cej 1000 losowo wybranych cz\u0105steczek. Dane pochodz\u0105 z pe\u0142nego zbioru 133 885 struktur obliczonych metodami DFT.</p>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%A7%AC-Struktura-tabeli-danych","title":"\ud83e\uddec Struktura tabeli danych\u00b6","text":"<p>Po wczytaniu pliku dataset zawiera nast\u0119puj\u0105ce typowe kolumny (nazwy mog\u0105 r\u00f3\u017cni\u0107 si\u0119 zale\u017cnie od wersji):</p> Kolumna Opis Typ smiles SMILES cz\u0105steczki (struktura 2D zakodowana tekstowo) string formula Wz\u00f3r sumaryczny cz\u0105steczki string rotational_constants_A/B/C Sta\u0142e rotacyjne (GHz) wyliczone z geometrii 3D float dipole_moment Moment dipolowy (Debye) float isotropic_polarizability Izotropowa polaryzowalno\u015b\u0107 (Bohr\u00b3) float homo Energia HOMO (eV) float lumo Energia LUMO (eV) float gap Przerwa energetyczna HOMO\u2013LUMO (eV) float electronic_spatial_extent Obj\u0119to\u015b\u0107 elektroniczna \u27e8r\u00b2\u27e9 (Bohr\u00b2) float zero_point_energy Energia zerowa (ZPE, Hartree) float internal_energy_0K Energia wewn\u0119trzna w 0 K (Hartree) float internal_energy_298K Energia w 298.15 K (Hartree) float enthalpy_298K Entalpia w 298.15 K (Hartree) float free_energy_298K Energia swobodna (Gibbs) w 298.15 K (Hartree) float heat_capacity Ciep\u0142o w\u0142a\u015bciwe C<sub>v</sub> (cal/mol\u00b7K) float mulliken_charges (opcjonalne) Rozmieszczenie \u0142adunku Mullikena float/list coordinates_X/Y/Z (opcjonalne) Wsp\u00f3\u0142rz\u0119dne 3D atom\u00f3w (\u00c5) list atom_types Lista atom\u00f3w (C/H/O/N/F) list num_atoms Liczba atom\u00f3w int num_heavy_atoms Liczba atom\u00f3w ci\u0119\u017ckich (C/O/N/F) int molecule_id Unikatowy identyfikator cz\u0105steczki int <p>\u26a0\ufe0f Uwaga: Dok\u0142adne kolumny w Twoim Excelu zale\u017c\u0105 od wersji konwertowanego pliku QM9, ale powy\u017csza lista obejmuje ca\u0142y standardowy zakres u\u017cywany w chemoinformatyce.</p>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%A7%A0-Kategorie-cech-w-zbiorze","title":"\ud83e\udde0 Kategorie cech w zbiorze\u00b6","text":"<p>Aby lepiej zrozumie\u0107 struktur\u0119 danych, mo\u017cna podzieli\u0107 kolumny QM9 na 4 g\u0142\u00f3wne grupy:</p>"},{"location":"02_eda_chem/EDA_QM9/#1%EF%B8%8F%E2%83%A3-Cechy-strukturalne","title":"1\ufe0f\u20e3 Cechy strukturalne\u00b6","text":"<ul> <li>SMILES</li> <li>Wz\u00f3r sumaryczny</li> <li>Liczba atom\u00f3w (og\u00f3\u0142em i ci\u0119\u017ckich)</li> <li>Wsp\u00f3\u0142rz\u0119dne 3D</li> <li>Typy atom\u00f3w</li> </ul> <p>\ud83d\udc49 u\u017cywane g\u0142\u00f3wnie do modelowania GNN i oblicze\u0144 geometrycznych.</p>"},{"location":"02_eda_chem/EDA_QM9/#2%EF%B8%8F%E2%83%A3-Cechy-energetyczne-(DFT)","title":"2\ufe0f\u20e3 Cechy energetyczne (DFT)\u00b6","text":"<ul> <li>ZPE</li> <li>Energie wewn\u0119trzne</li> <li>Enthalpia</li> <li>Energia swobodna</li> <li>HOMO / LUMO / GAP</li> </ul> <p>\ud83d\udd25 kluczowe dla modeli predykcyjnych w\u0142a\u015bciwo\u015bci kwantowych.</p>"},{"location":"02_eda_chem/EDA_QM9/#3%EF%B8%8F%E2%83%A3-Cechy-spektralne-i-rotacyjne","title":"3\ufe0f\u20e3 Cechy spektralne i rotacyjne\u00b6","text":"<ul> <li>Sta\u0142e rotacyjne A/B/C</li> <li>Ciep\u0142o w\u0142a\u015bciwe</li> <li>Przestrzenne rozci\u0105gni\u0119cie \u0142adunku (\u27e8r\u00b2\u27e9)</li> </ul>"},{"location":"02_eda_chem/EDA_QM9/#4%EF%B8%8F%E2%83%A3-Cechy-elektrostatyczne","title":"4\ufe0f\u20e3 Cechy elektrostatyczne\u00b6","text":"<ul> <li>Moment dipolowy</li> <li>Polaryzowalno\u015b\u0107</li> <li>Potencja\u0142y elektronowe i \u0142adunki (je\u015bli dost\u0119pne)</li> </ul>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%8E%AF-Dlaczego-te-dane-s%C4%85-warto%C5%9Bciowe?","title":"\ud83c\udfaf Dlaczego te dane s\u0105 warto\u015bciowe?\u00b6","text":"<ul> <li>Pochodz\u0105 z precyzyjnych oblicze\u0144 kwantowych, nie eksperyment\u00f3w.</li> <li>Charakteryzuj\u0105 si\u0119 wysok\u0105 jednorodno\u015bci\u0105 metodologiczn\u0105.</li> <li>Idealnie nadaj\u0105 si\u0119 do trenowania modeli ML predykcji w\u0142a\u015bciwo\u015bci molekularnych.</li> <li>Zawieraj\u0105 r\u00f3\u017cnorodno\u015b\u0107 strukturaln\u0105 przy ograniczonej wielko\u015bci cz\u0105steczek \u2014 kluczowe do nauki modeli GNN.</li> </ul>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%8E%AF-Cel-projektu:-Eksploracyjna-analiza-danych-(EDA)-zbioru-QM9","title":"\ud83c\udfaf Cel projektu: Eksploracyjna analiza danych (EDA) zbioru QM9\u00b6","text":"<p>Celem tego projektu jest przeprowadzenie kompleksowej eksploracyjnej analizy danych (EDA) na zbiorze QM9, zawieraj\u0105cym struktury i w\u0142a\u015bciwo\u015bci kwantowo-chemiczne ma\u0142ych cz\u0105steczek organicznych.</p>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%94%B9-G%C5%82%C3%B3wne-za%C5%82o%C5%BCenia-projektu","title":"\ud83d\udd39 G\u0142\u00f3wne za\u0142o\u017cenia projektu\u00b6","text":"<ol> <li><p>Zrozumienie struktury danych</p> <ul> <li>Identyfikacja kolumn, typ\u00f3w danych, brak\u00f3w danych i wyj\u0105tk\u00f3w.</li> <li>Analiza podzia\u0142u danych na cechy strukturalne, energetyczne, elektrostatyczne i rotacyjne.</li> </ul> </li> <li><p>Analiza statystyczna w\u0142a\u015bciwo\u015bci moleku\u0142</p> <ul> <li>Rozk\u0142ady podstawowych parametr\u00f3w: energie, moment dipolowy, HOMO/LUMO, GAP.</li> <li>Wykrywanie warto\u015bci odstaj\u0105cych i potencjalnych b\u0142\u0119d\u00f3w w danych.</li> </ul> </li> <li><p>Wizualizacja danych chemicznych</p> <ul> <li>Graficzne przedstawienie relacji mi\u0119dzy w\u0142a\u015bciwo\u015bciami.</li> <li>Wizualizacja cz\u0105steczek na podstawie SMILES i geometrii 3D (je\u015bli \u015brodowisko pozwoli).</li> </ul> </li> <li><p>Tworzenie podzbior\u00f3w roboczych</p> <ul> <li>Wydzielenie mniejszych pr\u00f3bek danych (np. 1000 wierszy) w celu szybkiej pracy i testowania modeli.</li> </ul> </li> <li><p>Przygotowanie danych do modeli ML</p> <ul> <li>Identyfikacja cech predykcyjnych i docelowych.</li> <li>Wst\u0119pne przekszta\u0142cenia danych i normalizacja dla przysz\u0142ych zada\u0144 predykcyjnych.</li> </ul> </li> </ol>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%8C%9F-Warto%C5%9B%C4%87-projektu","title":"\ud83c\udf1f Warto\u015b\u0107 projektu\u00b6","text":"<ul> <li>Projekt pozwala pokaza\u0107 umiej\u0119tno\u015bci w EDA i chemoinformatyce, w tym analiz\u0119 du\u017cych zbior\u00f3w danych chemicznych.</li> <li>Prezentuje profesjonalny workflow od wczytania danych, przez ich eksploracj\u0119, a\u017c po wizualizacj\u0119 i przygotowanie do ML.</li> <li>Stanowi doskona\u0142y element portfolio dla kandydat\u00f3w na stanowiska Data Scientist / Chemoinformatyk / Machine Learning Engineer w chemii.</li> </ul>"},{"location":"02_eda_chem/EDA_QM9/#duzo-record%C3%B3w-tworzenie-roboczego-df-z-1000-wierszami","title":"duzo record\u00f3w tworzenie roboczego df z 1000 wierszami\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#zmiana-nazw-kolumn","title":"zmiana nazw kolumn\u00b6","text":"<p>dodaa\u0107link do data setu + usuniecie kolumn z wagami</p>"},{"location":"02_eda_chem/EDA_QM9/#zmana-1-kolumny-na-licaby","title":"zmana 1 kolumny na licaby\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#Wizualizacja","title":"Wizualizacja\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#brakujace-wartosaci-i-duplikaty","title":"brakujace wartosaci i duplikaty\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#teraz-czas-na-sprawdzenie-czy-mamy-jkaie%C5%9B-odstaj%C4%85ce-wartosci-i-wyrysoanie-box-plot%C3%B3w","title":"teraz czas na sprawdzenie czy mamy jkaie\u015b odstaj\u0105ce wartosci i wyrysoanie box plot\u00f3w\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#wzory-kilku-czasteczek-o-wartosciach-odstajacych","title":"wzory kilku czasteczek o wartosciach odstajacych\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#kolejny-punkt","title":"kolejny punkt\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#teraz-czas-na-korelacja","title":"teraz czas na korelacja\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%94%9D-TOP-15-NAJSILNIEJSZYCH-KORELACJI","title":"\ud83d\udd1d TOP 15 NAJSILNIEJSZYCH KORELACJI\u00b6","text":"<p>Poni\u017cej przedstawiono 15 par w\u0142a\u015bciwo\u015bci z najsilniejszymi korelacjami w datasecie QM9:</p>"},{"location":"02_eda_chem/EDA_QM9/#Korelacje-perfekcyjne-(r-=-1.00)","title":"Korelacje perfekcyjne (r = 1.00)\u00b6","text":"<p>Te w\u0142a\u015bciwo\u015bci s\u0105 ze sob\u0105 matematycznie zwi\u0105zane poprzez definicje termodynamiczne:</p> <ul> <li>H \u2194 G \u2192 r = +1.0000 (Entalpia vs Energia Gibbsa)</li> <li>U \u2194 H \u2192 r = +1.0000 (Energia wewn\u0119trzna vs Entalpia)</li> <li>U \u2194 G \u2192 r = +1.0000 (Energia wewn\u0119trzna vs Energia Gibbsa)</li> <li>U \u2194 Cv \u2192 r = +1.0000 (Energia wewn\u0119trzna vs Pojemno\u015b\u0107 cieplna)</li> <li>H \u2194 Cv \u2192 r = +1.0000 (Entalpia vs Pojemno\u015b\u0107 cieplna)</li> <li>G \u2194 Cv \u2192 r = +1.0000 (Energia Gibbsa vs Pojemno\u015b\u0107 cieplna)</li> </ul> <p>\u26a0\ufe0f Uwaga: Te 6 par wykazuj\u0105 korelacj\u0119 1.0, co sugeruje, \u017ce s\u0105 ze sob\u0105 liniowo zale\u017cne. W modelowaniu ML nale\u017cy rozwa\u017cy\u0107 usuni\u0119cie redundantnych zmiennych, aby unikn\u0105\u0107 multikolinearno\u015bci.</p>"},{"location":"02_eda_chem/EDA_QM9/#Korelacje-bardzo-silne-(r-%3E-0.70)","title":"Korelacje bardzo silne (r &gt; 0.70)\u00b6","text":"<ul> <li><p>LUMO \u2194 gap \u2192 r = +0.8670 LUMO energy jest g\u0142\u00f3wnym sk\u0142adnikiem HOMO-LUMO gap</p> </li> <li><p>electronic_spatial_extent \u2194 U0 \u2192 r = +0.8288 Wi\u0119ksze cz\u0105steczki maj\u0105 wy\u017csz\u0105 energi\u0119 wewn\u0119trzn\u0105</p> </li> <li><p>polarizability \u2194 U0 \u2192 r = +0.7982 Polaryzowalno\u015b\u0107 ro\u015bnie z rozmiarem moleku\u0142y</p> </li> <li><p>zpve \u2194 U0 \u2192 r = +0.7758 Energia drga\u0144 punktu zerowego koreluje z ca\u0142kowit\u0105 energi\u0105</p> </li> <li><p>polarizability \u2194 zpve \u2192 r = +0.7655 Obie w\u0142a\u015bciwo\u015bci zale\u017c\u0105 od rozmiaru moleku\u0142y</p> </li> <li><p>polarizability \u2194 electronic_spatial_extent \u2192 r = +0.7170 Bezpo\u015brednia zale\u017cno\u015b\u0107 od obj\u0119to\u015bci elektronowej</p> </li> </ul>"},{"location":"02_eda_chem/EDA_QM9/#Korelacje-silne-(0.50-%3C-r-%3C-0.70)","title":"Korelacje silne (0.50 &lt; r &lt; 0.70)\u00b6","text":"<ul> <li>LUMO \u2194 zpve \u2192 r = +0.6705</li> <li>gap \u2194 zpve \u2192 r = +0.5705</li> <li>electronic_spatial_extent \u2194 zpve \u2192 r = +0.5284</li> </ul>"},{"location":"02_eda_chem/EDA_QM9/#%F0%9F%92%A1-Kluczowe-wnioski:","title":"\ud83d\udca1 Kluczowe wnioski:\u00b6","text":"<ol> <li>W\u0142a\u015bciwo\u015bci termodynamiczne (U, H, G, Cv) s\u0105 ze sob\u0105 idealnie skorelowane - wystarczy jedna z nich w modelach predykcyjnych</li> <li>LUMO i gap s\u0105 silnie powi\u0105zane - gap cz\u0119\u015bciowo zale\u017cy od LUMO</li> <li>Rozmiar moleku\u0142y (mierzony przez polarizability i electronic_spatial_extent) silnie wp\u0142ywa na w\u0142a\u015bciwo\u015bci energetyczne</li> <li>Brak silnych korelacji ujemnych w top 15 - wi\u0119kszo\u015b\u0107 zale\u017cno\u015bci jest dodatnia</li> </ol>"},{"location":"02_eda_chem/EDA_QM9/#Walidacja-SMILES---ile-b%C5%82%C4%99dnych-struktur,-dlaczego","title":"Walidacja SMILES - ile b\u0142\u0119dnych struktur, dlaczego\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#do-naprawy-potem","title":"do naprawy potem\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#Rozk%C5%82ad-train/valid/test---czy-zbalansowany","title":"Rozk\u0142ad train/valid/test - czy zbalansowany\u00b6","text":""},{"location":"02_eda_chem/EDA_QM9/#3.-ANALIZA-SK%C5%81ADU-CHEMICZNEGO-%F0%9F%A7%AA","title":"3. ANALIZA SK\u0141ADU CHEMICZNEGO \ud83e\uddea\u00b6","text":"<ul> <li>Rozk\u0142ad atom\u00f3w (H, C, N, O, F) - ile ka\u017cdego typu</li> <li>Masa molowa - rozk\u0142ad, median, percentyle</li> <li>Liczba atom\u00f3w ci\u0119\u017ckich - histogram, statystyki</li> <li>Liczba atom\u00f3w wodoru - analiza</li> <li>Wzory sumaryczne - najcz\u0119stsze sk\u0142ady</li> </ul>"},{"location":"02_eda_chem/EDA_QM9/#4.-ANALIZA-STRUKTURALNA-%F0%9F%94%AC","title":"4. ANALIZA STRUKTURALNA \ud83d\udd2c\u00b6","text":"<ul> <li>Liczba wi\u0105za\u0144 - single, double, triple, aromatic</li> <li>Liczba pier\u015bcieni - histogram, rozk\u0142ad 0-3 pier\u015bcienie</li> <li>Pier\u015bcienie aromatyczne vs alifatyczne</li> <li>Rotowalne wi\u0105zania - flexibility moleku\u0142</li> <li>Frakcja sp3 - saturacja vs aromatyczno\u015b\u0107</li> <li>Chiralno\u015b\u0107 - czy s\u0105 centra chiralne</li> </ul>"},{"location":"02_eda_chem/EDA_QM9/#5.-W%C5%81A%C5%9ACIWO%C5%9ACI-FIZYKOCHEMICZNE-(RDKit)-%E2%9A%97%EF%B8%8F","title":"5. W\u0141A\u015aCIWO\u015aCI FIZYKOCHEMICZNE (RDKit) \u2697\ufe0f\u00b6","text":"<ul> <li>LogP - lipofilowo\u015b\u0107, rozk\u0142ad, outliers</li> <li>TPSA - polar surface area, drug-likeness</li> <li>HBD/HBA - donory i akceptory wodoru</li> <li>Molar Refractivity - obj\u0119to\u015b\u0107 molekularna</li> <li>Regu\u0142a Lipi\u0144skiego - ile struktur spe\u0142nia Ro5</li> <li>Korelacje mi\u0119dzy deskryptorami - heatmap</li> </ul>"}]}